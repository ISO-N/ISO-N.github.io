---
title: 第12章 指针和数组
date: 2026-02-17 02:20:26
categories:
- [编程技术, C]
tags:
- C语言程序设计-现代方法
---
## 12.1 指针的算术运算

C 语言支持对指针进行**算术运算**，这是指针与数组紧密关联的基础。

### 指针加上整数

指针 `p` 加上整数 `j`，结果指向 `p` 所指元素之后第 `j` 个元素：

```c
int a[10], *p = &a[2];
// p 指向 a[2]
// p + 3 指向 a[5]
// p + 6 指向 a[8]
```

- 编译器会自动按**所指类型的大小**缩放偏移量（如 `int` 为 4 字节，`p + 3` 实际偏移 12 字节）

### 指针减去整数

指针 `p` 减去整数 `j`，结果指向 `p` 所指元素之前第 `j` 个元素：

```c
// p 指向 a[8]
// p - 3 指向 a[5]
// p - 5 指向 a[3]
```

### 两个指针相减

当两个指针指向**同一个数组**时，相减的结果是它们之间的**元素个数**（类型为 `ptrdiff_t`）：

```c
int a[10], *p = &a[2], *q = &a[8];
int diff = q - p;  // diff = 6
```

<aside>
⚠️

对不指向同一数组的两个指针做减法，结果是**未定义行为**。

</aside>

### 指针比较

可以用关系运算符（`<`、`<=`、`>`、`>=`）和相等运算符（`==`、`!=`）比较指向**同一数组**元素的指针：

```c
p < q   // 若 p 指向的元素在 q 之前，结果为 1
```

### 指向复合字面量的指针（C99）

C99 允许指针指向复合字面量：

```c
int *p = (int []){3, 0, 3, 4, 1};
// p 指向一个包含 5 个元素的匿名数组
```

## 12.2 指针用于数组处理

指针可以替代数组下标来遍历数组元素，在某些场景下更简洁高效。

### 用指针遍历数组

```c
int a[N], sum = 0;

// 用下标遍历
for (int i = 0; i < N; i++)
    sum += a[i];

// 用指针遍历（等价写法）
int *p;
for (p = &a[0]; p < &a[N]; p++)
    sum += *p;
```

<aside>
💡

`&a[N]` 虽然指向数组末尾之后的位置（不存在的元素），但 C 标准允许对它**取地址和比较**，只是不能**解引用**。

</aside>

### `*p++` 与 `(*p)++`

指针和自增运算符经常组合使用，需要注意优先级：

```c
*p++    // 等价于 *(p++)：先取 *p 的值，然后 p 向后移动
(*p)++  // 先取 *p 的值，然后将 *p 指向的值加 1
*++p    // 等价于 *(++p)：p 先向后移动，再取 *p 的值
++*p    // 等价于 ++(*p)：将 *p 指向的值加 1
```

<aside>
📌

`*p++` 是 C 语言中极其常见的惯用法，意思是"取当前元素并移动到下一个"。

</aside>

### 数组求和的惯用写法

```c
int a[N], sum = 0;
int *p = a;                  // a 等价于 &a[0]
while (p < a + N)
    sum += *p++;
```

## 12.3 用数组名作为指针

在大多数表达式中，数组名会自动**退化（decay）**为指向其首元素的指针。

### 数组名即指针

```c
int a[10];
// a 等价于 &a[0]，类型为 int *
```

因此可以直接写：

```c
int *p = a;        // 等价于 int *p = &a[0]
*a = 7;            // 等价于 a[0] = 7
*(a + 3) = 10;     // 等价于 a[3] = 10
```

### 数组名不是左值

虽然数组名可以当指针用，但它是一个**不可修改的左值**，不能对数组名赋值或自增：

```c
int a[10];
a++;       // ❌ 错误！数组名不能自增
a = p;     // ❌ 错误！数组名不能被赋值
```

### 下标运算符 `[]` 与指针

`a[i]` 实际上被编译器翻译为 `*(a + i)`，因此下标运算符可以用于**任何**指针：

```c
int a[10], *p = a;
p[3] = 100;        // 等价于 *(p + 3) = 100，即 a[3] = 100
```

<aside>
💡

甚至可以写 `3[a]`（等价于 `*(3 + a)` 即 `a[3]`），但这只是理论上合法，**绝不应该这样写**。

</aside>

### 数组型实参与指针型形参

当数组作为函数参数时，传递的是**指向首元素的指针**（而非整个数组的副本）：

```c
// 以下两种声明完全等价
int sum_array(int a[], int n);
int sum_array(int *a, int n);
```

```c
int sum_array(int *a, int n) {
    int sum = 0;
    for (int i = 0; i < n; i++)
        sum += a[i];       // 或 sum += *(a + i)
    return sum;
}
```

<aside>
⚠️

在函数内部对数组参数使用 `sizeof` 得到的是**指针的大小**（通常 4 或 8 字节），而不是原始数组的大小。因此必须额外传递数组长度。

</aside>

### 用指针作为数组名

函数内的指针形参可以像数组一样使用下标，也可以对其做自增等操作：

```c
int sum_array(int *a, int n) {
    int sum = 0;
    for (; n > 0; n--)
        sum += *a++;       // 惯用法：取值并移动指针
    return sum;
}
```

## 12.4 指针和多维数组

### 多维数组的内存布局

C 中的二维数组是"数组的数组"，按**行优先**连续存储：

```c
int a[3][4];
// 内存布局：a[0][0] a[0][1] a[0][2] a[0][3] a[1][0] ... a[2][3]
```

### 处理多维数组元素的指针

可以用 `int *` 指针遍历二维数组的所有元素：

```c
int a[3][4];
int *p;
for (p = &a[0][0]; p <= &a[2][3]; p++)
    *p = 0;      // 将所有元素清零
```

### 处理多维数组行的指针

`a[i]` 是第 `i` 行的数组名，退化为 `int *`（指向该行首元素）；而 `a` 本身退化为指向第一行的指针，类型是 `int (*)[4]`（指向"含 4 个 int 的数组"的指针）：

```c
int a[3][4];
int (*p)[4];             // p 是指向"int[4]"的指针

for (p = a; p < a + 3; p++)
    (*p)[0] = 0;         // 将每行的第一个元素清零
```

<aside>
⚠️

注意区分：

- `int (*p)[4]`：指向"含 4 个 int 的数组"的指针
- `int *p[4]`：含 4 个 `int *` 的**指针数组**

括号的位置至关重要！

</aside>

### 用多维数组名作为指针

```c
int a[3][4];

a         // 类型 int (*)[4]，指向 a[0]（第一行）
a[0]      // 类型 int *，指向 a[0][0]（第一行第一个元素）
*a        // 等价于 a[0]，类型 int *
a[i][j]   // 等价于 *(*(a + i) + j)
```

| **表达式** | **等价形式** | **类型** | **含义** |
| --- | --- | --- | --- |
| `a` | `&a[0]` | `int (*)[4]` | 指向第 0 行 |
| `a + i` | `&a[i]` | `int (*)[4]` | 指向第 i 行 |
| `a[i]` | `*(a + i)` | `int *` | 指向第 i 行首元素 |
| `a[i][j]` | `*(*(a + i) + j)` | `int` | 第 i 行第 j 列的值 |

## 12.5 C99 中的指针和变长数组

### VLA 与指针

C99 的变长数组（VLA）可以与指针结合使用。指向 VLA 的指针的类型取决于 VLA 的维度：

```c
int n = 5;
int a[n];
int *p = a;       // 普通指针即可指向一维 VLA
```

### 指向变长数组行的指针

对于二维 VLA，指向其"行"的指针需要使用变长类型：

```c
void f(int m, int n) {
    int a[m][n];
    int (*p)[n] = a;     // p 的类型依赖于变量 n
    // p++ 会跳过 n 个 int
}
```

### VLA 形参

C99 允许在函数形参中使用 VLA 语法，使维度信息更加清晰：

```c
// 传统写法
int sum_2d(int a[][4], int rows);

// C99 VLA 写法：列数也可以是变量
int sum_2d(int rows, int cols, int a[rows][cols]) {
    int sum = 0;
    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            sum += a[i][j];
    return sum;
}
```

<aside>
📌

使用 VLA 形参时，维度参数（如 `rows`、`cols`）必须出现在数组参数**之前**，因为编译器需要先知道维度大小。

</aside>

### 使用 `static` 在数组形参声明中（C99）

C99 允许在数组形参的第一维中使用 `static` 关键字，表示传入的数组至少有指定数量的元素：

```c
int sum(int a[static 3], int n);
// 告诉编译器：a 至少指向 3 个 int 元素
```

- 这是一个**提示**，帮助编译器进行优化
- 如果实际传入的数组长度不足，行为是**未定义的**

---

> 第 12 章的核心：数组名在表达式中退化为指针、指针算术按元素大小缩放、`a[i]` 等价于 `*(a + i)`、多维数组行指针的类型声明。掌握这些是理解 C 语言内存模型的关键。
>