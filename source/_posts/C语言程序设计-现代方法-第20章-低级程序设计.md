---
title: 第20章 低级程序设计
date: 2026-02-17 02:20:31
categories:
- [编程技术, C]
tags:
- C语言程序设计-现代方法
---
## 20.1 位运算符

C 语言提供了 6 个**位运算符**（bitwise operators），可以对整数的**二进制位**进行操作。这些运算符适用于所有整数类型（`char`、`short`、`int`、`long` 及其 `unsigned` 版本），但通常用于 `unsigned` 类型以避免符号位带来的问题。

### 移位运算符

| 运算符 | 含义 | 示例 |
| --- | --- | --- |
| `<<` | 左移 | `13 << 2` → `52` |
| `>>` | 右移 | `13 >> 2` → `3` |

**左移** `i << j`：将 `i` 的二进制位向左移动 `j` 位，右侧补 **0**，相当于乘以 $2^j$：

```c
unsigned short i = 13;   // 二进制：0000000000001101
unsigned short j = i << 2;
// 结果：0000000000110100 = 52
```

**右移** `i >> j`：将 `i` 的二进制位向右移动 `j` 位：

- **无符号类型**：左侧补 **0**（逻辑右移）
- **有符号类型**：结果是**实现定义**的，可能补 0 也可能补符号位（算术右移）

```c
unsigned short i = 13;   // 二进制：0000000000001101
unsigned short j = i >> 2;
// 结果：0000000000000011 = 3
```

<aside>
⚠️

**避免对有符号整数进行移位操作！** 右移有符号负数的行为是**实现定义**的，左移有符号负数可能导致**未定义行为**。在位运算中始终使用 `unsigned` 类型。

</aside>

### 按位取反、与、异或、或

| 运算符 | 含义 | 规则 |
| --- | --- | --- |
| `~` | 按位取反（NOT） | 0 → 1，1 → 0 |
| `&` | 按位与（AND） | 两个都是 1 才为 1 |
| `^` | 按位异或（XOR） | 不同为 1，相同为 0 |
| `|` | 按位或（OR） | 有一个为 1 就为 1 |

真值表：

```
a   b   ~a   a&b   a^b   a|b
0   0    1     0     0     0
0   1    1     0     1     1
1   0    0     0     1     1
1   1    0     1     0     1
```

<aside>
📌

注意区分**位运算符**和**逻辑运算符**：

- `&`（按位与）vs `&&`（逻辑与）
- `|`（按位或）vs `||`（逻辑或）
- `~`（按位取反）vs `!`（逻辑非）

逻辑运算符的结果只有 0 或 1，而位运算符对每一位分别操作。

</aside>

### 用位运算符操作位

位运算最常见的应用是将整数的某些位作为**标志位**（flag），每一位代表一个布尔值。

**设置第 n 位**（置 1）：

```c
i |= 1 << n;
// 例：设置第 3 位
// i = i | 00001000
```

**清除第 n 位**（置 0）：

```c
i &= ~(1 << n);
// 例：清除第 3 位
// i = i & 11110111
```

**测试第 n 位**（判断是否为 1）：

```c
if (i & (1 << n))
    printf("第 %d 位为 1\n", n);
```

**翻转第 n 位**（0 变 1，1 变 0）：

```c
i ^= 1 << n;
```

### 用位运算符操作位域

可以用**宏**定义位掩码，使代码更具可读性：

```c
#define BOLD      1     // 00000001
#define ITALIC    2     // 00000010
#define UNDERLINE 4     // 00000100

unsigned char font_attrs = 0;

font_attrs |= BOLD | ITALIC;       // 设置粗体和斜体
font_attrs &= ~ITALIC;             // 清除斜体

if (font_attrs & BOLD)             // 检查是否粗体
    printf("Bold is on\n");
```

<aside>
💡

掩码值通常使用 2 的幂（1、2、4、8、16 …），确保每个标志占**独立的一位**。也可以用左移表达式使其更直观：

```c
#define BOLD      (1 << 0)   // 第 0 位
#define ITALIC    (1 << 1)   // 第 1 位
#define UNDERLINE (1 << 2)   // 第 2 位
```

</aside>

### 使用 XOR 进行加密

XOR 运算的特性：同一个值异或两次恢复原值（`a ^ b ^ b == a`），可以用于简单加密：

```c
// 加密
char original = 'A';
char key = 0x7F;
char encrypted = original ^ key;

// 解密（再异或一次）
char decrypted = encrypted ^ key;   // 恢复为 'A'
```

---

## 20.2 结构中的位域

### 位域的声明

C 语言允许在结构中声明**位域**（bit-field）：指定成员只占特定数量的**位**，而不是完整的字节或字：

```c
struct file_date {
    unsigned int day   : 5;    // 1~31，需要 5 位
    unsigned int month : 4;    // 1~12，需要 4 位
    unsigned int year  : 7;    // 0~127，需要 7 位（表示相对年份）
};
```

- `: 5` 表示该成员只占 **5 个位**
- 位域的类型通常是 `unsigned int` 或 `int`（C99 还允许 `_Bool`）
- 整个 `struct file_date` 可能只占 **16 位**（2 字节）

### 位域的使用

位域成员的使用方式与普通结构成员**完全相同**：

```c
struct file_date fd;
fd.day = 28;
fd.month = 12;
fd.year = 48;     // 假设相对于 1980 年 → 2028 年

printf("%d/%d/%d\n", fd.month, fd.day, fd.year + 1980);
// 输出：12/28/2028
```

### 位域的存储方式

编译器将位域**打包**到一个或多个"存储单元"（通常是 `unsigned int`）中：

```c
struct example {
    unsigned int a : 3;    // 第一个存储单元的前 3 位
    unsigned int b : 5;    // 同一个存储单元的接下来 5 位
    unsigned int c : 8;    // 同一个存储单元的接下来 8 位
    // 以上共 16 位，可能还有剩余位未使用
};
```

<aside>
📌

位域的**存储细节**（如位的排列顺序、跨存储单元的方式）是**实现定义**的，不同编译器和平台可能不同。因此位域**不适合**用于需要精确控制二进制格式的场景（如网络协议、文件格式），这种情况应使用**位运算符**手动操作。

</aside>

### 未命名位域与零长度位域

**未命名位域**：用于占位填充，不可访问：

```c
struct s {
    unsigned int a : 4;
    unsigned int   : 2;    // 2 位的填充（不可访问）
    unsigned int b : 6;
};
```

**零长度位域**：强制下一个位域从新的存储单元开始：

```c
struct s {
    unsigned int a : 4;
    unsigned int   : 0;    // 强制对齐到下一个存储单元
    unsigned int b : 8;    // 从新的存储单元开始
};
```

### 位域的限制

<aside>
⚠️

位域有以下限制：

- **不能取地址**：`&[fd.day](http://fd.day)` 是非法的，因为位域可能不在字节边界上
- **不能用数组**：不能声明位域数组
- **可移植性差**：位的排列顺序和填充方式是实现定义的
- **不能跨存储单元**：某些编译器不允许位域跨越存储单元的边界
</aside>

---

## 20.3 其他低级技术

### 用 typedef 定义与机器相关的类型

为了提高**可移植性**，可以用 `typedef` 为与机器相关的类型创建别名：

```c
typedef unsigned char BYTE;    // 精确表示 8 位
typedef unsigned short WORD;   // 精确表示 16 位
typedef unsigned int DWORD;    // 精确表示 32 位
```

这样在不同平台上，只需修改 `typedef`，程序的其他部分不受影响。

<aside>
📌

C99 在 `<stdint.h>` 中提供了**精确宽度整数类型**，更加标准化：

```c
#include <stdint.h>

int8_t    a;    // 精确 8 位有符号
uint8_t   b;    // 精确 8 位无符号
int16_t   c;    // 精确 16 位有符号
uint16_t  d;    // 精确 16 位无符号
int32_t   e;    // 精确 32 位有符号
uint32_t  f;    // 精确 32 位无符号
int64_t   g;    // 精确 64 位有符号
uint64_t  h;    // 精确 64 位无符号
```

</aside>

### 用 sizeof 确定类型大小

`sizeof` 运算符返回类型或表达式占用的**字节数**：

```c
printf("int: %zu bytes\n", sizeof(int));
printf("double: %zu bytes\n", sizeof(double));
printf("struct file_date: %zu bytes\n", sizeof(struct file_date));
```

`sizeof` 的结果类型是 `size_t`（无符号整数类型），其大小因平台而异。

### 用联合提供数据的多种视角

联合允许用**不同的方式**查看同一段内存，这在低级编程中很有用：

```c
union int_or_bytes {
    int i;
    unsigned char bytes[sizeof(int)];
};

union int_or_bytes u;
u.i = 0x12345678;

// 查看 int 的各个字节
for (int j = 0; j < sizeof(int); j++)
    printf("%02X ", u.bytes[j]);
// 在小端机器上输出：78 56 34 12
```

<aside>
⚠️

通过联合查看数据的字节表示是一种常见的低级技巧，但结果**依赖于字节序**（endianness）：

- **小端**（little-endian）：低字节在前（x86/x64）
- **大端**（big-endian）：高字节在前（网络字节序）

编写可移植代码时需要注意字节序差异。

</aside>

### 用指针作为地址

在嵌入式系统和操作系统编程中，指针有时直接用来表示**物理内存地址**：

```c
// 假设硬件寄存器映射在地址 0x40021000
volatile unsigned int *gpio = (volatile unsigned int *)0x40021000;
*gpio = 0x01;   // 向硬件寄存器写入值
```

<aside>
📌

`volatile` 关键字在这里至关重要——它告诉编译器：

- 每次使用该指针时都必须从**真实内存地址**读取
- 不能将值缓存在寄存器中
- 不能优化掉看似"无用"的读写操作

硬件寄存器的值可能随时被硬件改变，因此必须使用 `volatile`。

</aside>

### volatile 类型限定符

`volatile` 声明的变量可能被程序以外的因素改变（硬件、中断、其他线程）：

```c
volatile int flag = 0;

// 中断处理函数中
void interrupt_handler(void) {
    flag = 1;
}

// 主循环中等待中断
while (!flag) {
    // 如果 flag 没有 volatile，编译器可能优化掉这个循环
    // 因为在循环内部 flag 没有被修改
}
```

---

## 20.4 位运算的常见应用

### 交换两个变量（不用临时变量）

利用 XOR 的性质可以不使用临时变量交换两个值：

```c
a ^= b;
b ^= a;
a ^= b;
// 现在 a 和 b 的值互换了
```

<aside>
📌

这种技巧虽然巧妙，但在现代编程中**不推荐**使用。用临时变量交换更清晰，而且编译器通常能将其优化得同样高效。当 `a` 和 `b` 是同一个变量时，XOR 交换会产生错误结果（变为 0）。

</aside>

### 检测二的幂

判断一个正整数是否是 2 的幂：

```c
if (n > 0 && (n & (n - 1)) == 0)
    printf("%d 是 2 的幂\n", n);
```

原理：2 的幂的二进制表示中只有**一个** 1（如 `1000`），减 1 后变成全 1（如 `0111`），两者按位与结果为 0。

### 提取和组合字节

从 32 位整数中提取各个字节：

```c
unsigned int val = 0xAABBCCDD;
unsigned char byte0 = val & 0xFF;           // 最低字节：0xDD
unsigned char byte1 = (val >> 8) & 0xFF;    // 第 2 字节：0xCC
unsigned char byte2 = (val >> 16) & 0xFF;   // 第 3 字节：0xBB
unsigned char byte3 = (val >> 24) & 0xFF;   // 最高字节：0xAA
```

将四个字节组合成一个 32 位整数：

```c
unsigned int result = (byte3 << 24) | (byte2 << 16)
                    | (byte1 << 8) | byte0;
```

---

## 本章要点速查

| **概念** | **要点** |
| --- | --- |
| 移位运算符 | `<<` 左移（乘 $2^n$），`>>` 右移（除 $2^n$），对 `unsigned` 类型最安全 |
| 按位运算符 | `~` 取反、`&` 与、`^` 异或、`|` 或，逐位操作 |
| 位掩码操作 | 设置位用 `|=`，清除位用 `&= ~`，测试位用 `&`，翻转位用 `^=` |
| 位域 | 结构成员指定位宽（`: n`），节省空间但**可移植性差** |
| `volatile` | 防止编译器优化，用于硬件寄存器、中断变量 |
| 联合查看内存 | 用联合以不同类型视角查看同一段内存，注意**字节序** |
| 精确宽度类型 | C99 `<stdint.h>` 提供 `uint8_t`、`int32_t` 等精确宽度类型 |
| 指针作为地址 | 嵌入式中将指针指向硬件地址，配合 `volatile` 使用 |

> 本章是 C 语言与底层硬件交互的基础。核心要点：掌握 **6 个位运算符**及其典型应用（设置/清除/测试位）、理解**位域**的用法和局限性、知道 `volatile` 在**硬件编程**中的重要作用、善用 `typedef` 和 `<stdint.h>` 提高**可移植性**。在需要精确控制二进制格式时，优先使用**位运算符**而非位域。
>