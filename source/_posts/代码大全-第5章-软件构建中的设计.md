---
title: 第5章 软件构建中的设计
date: 2026-02-17 15:24:56
categories:
- [软件工程, 理论]
tags:
- 代码大全
---
## 5.1 设计中的挑战

- 设计是一个**"险恶的问题"（Wicked Problem）**：你必须先"解决"它一次才能明确定义它，然后再次解决才能给出可行方案
- 设计是一个**草率的过程**：即使最终产品整洁，过程中充满了错误的开始和走弯路
- 设计是关于**权衡与取舍**的：没有完美的设计，只有在各种约束下的最佳折中
- 设计受到**限制条件**的约束：资源、时间、技术能力等
- 设计是**不确定的**：同一个问题可能有多种合理的设计方案
- 设计是一个**启发式过程**：没有固定的公式可以直接得出结果，需要反复试验和迭代

## 5.2 关键的设计概念

### 软件的首要技术使命：管理复杂度

- 软件开发中最大的挑战是**管理复杂度**
- 人类大脑一次只能处理有限数量的信息，设计的目标就是将复杂度降低到人脑可以处理的水平
- 两种管理复杂度的方式：
    - **把复杂度最小化**：减少任何时刻需要关注的本质复杂度
    - **避免制造不必要的复杂度**：不要引入非本质的、偶然的复杂度

### 理想的设计特征

- **最小复杂度**：避免做出"聪明的"设计，应做出"简单的、易于理解的"设计
- **易于维护**：为维护程序员着想，设计出自明的（self-explanatory）系统
- **松散耦合**：模块之间的关联尽量少，使得各模块可以独立理解、修改和测试
- **可扩展性**：能够在不破坏已有结构的情况下增强系统功能
- **可重用性**：系统的组成部分可以在其他系统中使用
- **高扇入**：让大量的类使用某个给定的类（说明该类设计良好、通用性高）
- **低扇出**：一个类应该少量地使用其他类（不超过约 7 个）
- **可移植性**：系统应该容易移植到其他环境
- **精简性**：不多也不少，恰好满足需求（伏尔泰："一本书的完成，不在于它不能再加入什么，而在于不能再删去什么"）
- **层次性**：保持各层次的抽象一致，能在任意层次上观察系统而不需要深入到其他层次
- **标准技术的使用**：尽量使用常见的、标准化的方法，减少理解难度

## 5.3 设计构造块：启发式方法

### 找出现实世界中的对象

- 辨识对象及其属性（数据与方法）
- 确定可以对对象做什么
- 确定各对象可以对其他对象做什么
- 确定对象的哪些部分是可见的、哪些是不可见的（信息隐藏）
- 定义每个对象的公共接口

### 形成一致的抽象

- **抽象**是一种以简化方式看待复杂操作的能力
- 好的类接口就是一个抽象：你不需要知道内部实现，只需知道接口提供什么
- 在不同的层次上保持抽象的一致性

### 封装实现细节

- 封装是抽象的延伸：抽象说"你可以从高层看这个对象"，封装说"你不能看到对象中除此之外的任何细节"
- 封装帮助管理复杂度：当你不去看内部细节时，也就无需记住它们

### 当继承能简化设计时就使用继承

- 继承的意义在于"B 是 A 的一种（is-a）"关系
- 优先使用**组合/包含（has-a）**而非继承，除非继承能真正简化设计
- 遵循**里氏替换原则（LSP）**：子类型必须能够替换其基类型

### 隐藏秘密（信息隐藏）

- 每个类或模块都应该有一个"秘密"——即对外隐藏的设计决策
- 两类秘密：
    - **隐藏复杂度**：使你不必去面对它，除非你要专门去研究它
    - **隐藏变化源**：当变化发生时，影响只局限在一个模块内
- **障碍**：过度分发信息、循环依赖、把类的数据当成全局数据来用

### 找出容易变化的区域

- 识别出看起来可能会变化的项目，将它们分离出来
- 常见的变化区域：
    - 业务规则
    - 硬件依赖
    - 输入和输出
    - 非标准的语言特性
    - 困难的设计和构建区域
    - 状态变量
    - 数据量的限制

### 保持松散耦合

- **耦合度衡量标准**：
    - **规模**：模块之间连接的数量（越少越好）
    - **可见性**：连接的显著程度（参数列表比全局变量好）
    - **灵活性**：连接的可变程度（越容易改变越好）
- 耦合的类型（由松到紧）：
    1. 简单数据参数耦合（最好）
    2. 简单对象耦合
    3. 对象参数耦合
    4. 语义耦合（最差，依赖于对象内部的实现知识）

### 查阅常用的设计模式

- 设计模式提供了现成的抽象，减少复杂度
- 常用设计模式：

| **模式** | **描述** |
| --- | --- |
| Abstract Factory | 通过指定对象组的类型而非单个对象来创建一组相关对象 |
| Adapter | 将一个类的接口转换成客户端所期望的另一种接口 |
| Bridge | 将接口与实现分离，使之可以独立变化 |
| Composite | 创建由同类子对象组合构成的对象，操作方式与单个对象一致 |
| Decorator | 动态地为对象附加额外的职责，无需修改对象本身 |
| Facade | 为复杂的子系统提供一个统一的简化接口 |
| Factory Method | 让子类决定实例化哪一个类，将对象的创建延迟到子类 |
| Iterator | 提供一种方法顺序访问聚合对象中的各个元素，而无需暴露其内部表示 |
| Observer | 定义对象间一对多的依赖关系，当一个对象状态改变时，所有依赖者都得到通知 |
| Singleton | 保证一个类仅有一个实例，并提供全局访问点 |
| Strategy | 定义一组算法，将每个算法封装起来，使之可以互相替换 |
| Template Method | 定义算法的骨架，将某些步骤延迟到子类中实现 |

### 其他启发式方法

- **高内聚**：类内部的方法和数据应紧密相关
- **构造分层结构**：用分层来组织信息
- **严格约定（契约式设计）**：对每个子程序的前条件和后条件进行约定
- **分配职责**：思考"这个对象应该负责什么？"
- **为测试而设计**：从一开始就考虑如何测试系统
- **避免失误**：有意识地规避以往犯过的错误
- **蛮力突破**：如果启发式方法都行不通，就用最简单粗暴的方式先让它工作

## 5.4 设计实践

### 迭代

- 设计本质上是迭代的，不要期望第一遍就做对
- 好的设计通常来自于多次尝试和改进

### 分而治之

- 将系统拆解为多个子系统和子问题
- 用不同层次的抽象逐步攻克

### 自上而下和自下而上的设计

- **自上而下**：从最高的抽象层次开始，逐步分解为更具体的组件
- **自下而上**：从已知的细节和具体实现开始，组合成高层结构
- 实践中通常**两者结合**使用

### 建立实验性原型

- 用最少的代码来回答特定的设计问题
- 原型的目的是为了**学习**，而非直接使用
- 原型写完即弃，不要心疼

### 合作设计

- 与同事讨论设计方案（正式的设计评审 / 非正式的走查）
- **两个人的设计通常优于一个人的设计**

### 记录你的设计成果

- 将设计以文档形式保留（图示、Wiki 文档、代码注释等）
- 记录**设计决策和原因**，而不仅仅是结果

## 5.5 对流行方法论的评论

- 不要把任何一种方法论当成宗教来信奉
- 应该**取其精华**，根据项目实际情况灵活选用设计方法
- 关键是要进行设计，而非严格遵循某种特定的过程

## 5.6 核对表：软件构造中的设计

### 设计实践

- [ ]  你已经做过多次迭代，并且从众多尝试结果中选择最佳的一种，而不是简单选择第一次尝试的结果吗？
- [ ]  你尝试用多种方案来分解系统，以确定最佳方案吗？
- [ ]  你同时用自下而上和自上而下的方法来解决设计问题吗？
- [ ]  为了解决某些特定的问题，你对系统中的风险部分或者不熟悉的部分创建过原型、写出数量最少的可抛弃的代码吗？
- [ ]  你的设计方案被其他人检查了吗（无论正式与否）？
- [ ]  你一直在展开设计，直到实施细节跃然纸上了吗？
- [ ]  你用某种适当的技术——比如说 Wiki、电子邮件、挂图、数码照片、UML、CRC 卡或者在代码写注释——来保留设计成果吗？

### 设计目标

- [ ]  你的设计是否充分地处理了由系统架构层定义出并且推迟确定的事项？
- [ ]  你的设计被划分成层次吗？
- [ ]  你对把这一程序分解成为子程序、包和类的方式感到满意吗？
- [ ]  你把对这个类分解成为子程序的方法感到满意吗？
- [ ]  类与类之间的交互关系是否已设计为最小化了？
- [ ]  类和子程序是否被设计为能够在其它的系统中重用？
- [ ]  程序是不是易于维护？
- [ ]  设计是否精简？设计出来的每一部分都绝对必要吗？
- [ ]  设计中是否采用了标准的技术？是否避免使用怪异且难以理解的元素？
- [ ]  整体而言，你的设计是否有助于最小化偶然的和本质的复杂度吗？

---

<aside>
📌

**核心要点**：设计是管理复杂度的过程。好的设计是简单的、模块化的、低耦合高内聚的。没有唯一正确的设计方案，持续迭代和权衡才是正途。

</aside>