---
title: 第7章 高质量的子程序
date: 2026-02-17 15:24:57
categories:
- [软件工程, 理论]
tags:
- 代码大全
---
## 7.1 创建子程序的正当理由

- **降低复杂度**：将复杂的逻辑隐藏在子程序内部，调用处只需关注"做什么"而非"怎么做"
- **引入中间的、可理解的抽象**：用一个有意义的子程序名称替代一段晦涩的代码
- **避免代码重复**：将重复出现的代码提取为子程序，修改时只改一处
- **支持子类化（继承覆盖）**：将可能被覆盖的逻辑放入独立的子程序中，方便派生类重写
- **隐藏顺序**：如果操作必须按特定顺序执行，将它们封装在一个子程序中
- **隐藏指针操作**：指针操作容易出错且难读，封装后可读性更好
- **提高可移植性**：将平台相关的代码集中在子程序中，移植时只需修改这些子程序
- **简化复杂的布尔判断**：将复杂的条件表达式提取为命名良好的布尔函数
- **提高性能**：将代码集中在子程序中，方便对热点进行针对性优化
- **确保所有的子程序都很小**这本身不应成为理由——**创建子程序最重要的理由是降低复杂度和提高可读性**
- 即使一段代码只有一两行，如果赋予它一个好的名字能提高可读性，也值得提取为子程序

## 7.2 在子程序层上设计

- **内聚性（Cohesion）** 是衡量子程序质量的最重要标准之一
- **最佳内聚性**：
    - **功能内聚（Functional Cohesion）**：子程序只执行一个操作，如 `GetCustomerName()`、`CalculateLoanPayment()`
- **可接受的内聚性**：
    - **顺序内聚（Sequential Cohesion）**：子程序内的操作必须按特定顺序执行，前一个操作的输出是后一个操作的输入
    - **通信内聚（Communicational Cohesion）**：子程序内的操作使用相同的数据，但彼此没有顺序要求
    - **临时内聚（Temporal Cohesion）**：操作因为需要在同一时间执行而被放在一起（如 `Startup()`、`Shutdown()`）
- **不可接受的内聚性**：
    - **过程内聚（Procedural Cohesion）**：操作按特定顺序执行，但不使用相同的数据
    - **逻辑内聚（Logical Cohesion）**：多个操作被塞进同一个子程序，通过传入一个控制标志来选择执行哪个——应拆分为多个子程序
    - **巧合内聚（Coincidental Cohesion）**：子程序内的操作之间没有任何关联，纯属偶然放在一起

## 7.3 好的子程序名字

- **描述子程序所做的所有事情**：名字应完整反映子程序的功能，如果难以命名，说明子程序职责不清晰
- **避免使用无意义或模糊的动词**：如 `HandleCalculation()`、`PerformServices()`、`ProcessInput()`——这些名字没有传达任何具体信息
- **不要仅用数字来区分子程序名**：如 `OutputUser1()`、`OutputUser2()`
- **根据需要确定名字的长度**：
    - 研究表明，变量名的最佳长度为 **9~15 个字符**，子程序名通常更长
    - 名字太短可能不够清楚，太长则难以阅读
- **函数命名时应描述返回值**：如 `cos()`、[`customerId.Next](http://customerId.Next)()`、`printer.IsReady()`
- **过程命名时使用强烈的"动词 + 宾语"格式**：如 `PrintDocument()`、`CheckOrderInfo()`
    - 在面向对象语言中，宾语可省略（因为对象本身就是宾语）：`document.Print()`、`orderInfo.Check()`
- **使用对仗词**：
    - `add / remove`
    - `begin / end`
    - `create / destroy`
    - `insert / delete`
    - `first / last`
    - `get / put`（或 `get / set`）
    - `increment / decrement`
    - `lock / unlock`
    - `min / max`
    - `next / previous`
    - `old / new`
    - `open / close`
    - `show / hide`
    - `source / target`
    - `start / stop`
    - `up / down`
- **为常见操作确立命名约定**：在整个项目中保持一致

## 7.4 子程序可以有多长

- **理论上的最佳长度**：研究表明，子程序长度与错误率之间的关系如下：
    - 子程序长度在 **150 行以内**时，错误率并不随长度增加而增加
    - 让子程序保持在 **200 行以内**是一个合理的上限（不算注释和空行）
- **不要硬性规定必须拆分**：如果一个较长的子程序逻辑清晰、结构良好，强行拆分反而可能降低可读性
- 关键不是长度本身，而是**内聚性、嵌套深度、变量数量、决策点数量和注释**

## 7.5 如何使用子程序参数

- **按照输入-修改-输出的顺序排列参数**：
    - 先列出**纯输入参数**
    - 再列出**既输入又输出的参数**
    - 最后列出**纯输出参数**
- **考虑创建自己的 `IN` 和 `OUT` 关键字**（通过宏或注释）来标识参数的用途
- **如果几个子程序都用了类似的参数，应让这些参数的排列顺序保持一致**
- **使用所有的参数**：如果传入了一个参数但从未使用，就删掉它
- **把状态或错误变量放在最后**
- **不要把子程序参数用作工作变量**：应将参数值赋给局部变量后再操作
- **在接口中对参数的假设加以说明**：
    - 参数是否只用于输入？
    - 参数的单位是什么？
    - 如果没有使用枚举类型，状态码的含义是什么？
    - 期望的值范围是什么？
    - 不应出现的特定值是什么？
- **将子程序的参数个数限制在 7 个左右**：超过 7 个参数会使子程序难以理解和使用
- **考虑对参数采用命名规范来表达其用途**：如用前缀 `i_` 表示输入、`o_` 表示输出
- **为子程序传递子程序需要的变量或对象**：
    - 如果只需要对象的一两个属性，传属性值，这样子程序与对象之间更松耦合
    - 如果需要对象的多个属性，传对象本身

## 7.6 使用函数时的特别注意事项

- **函数（function）** 是有返回值的子程序；**过程（procedure）** 是没有返回值的子程序
- **什么时候使用函数，什么时候使用过程？**
    - 如果子程序的主要目的是返回由其名字所标识的值 → 使用函数
    - 如果子程序的主要目的是执行操作 → 使用过程（即使需要反馈状态，也通过输出参数来传递）
- **设置函数的返回值**：
    - **确保所有可能的执行路径都有返回值**
    - **不要返回指向局部变量的引用或指针**

## 7.7 宏子程序和内联子程序

### 宏的限制

- **将宏表达式整个括起来**：`#define Cube(a) ((a) * (a) * (a))`，避免展开后优先级混乱
- **将含有多条语句的宏用大括号括起来**
- **用给子程序命名的方式来给展开后代码类似子程序的宏命名**，方便未来替换为真正的子程序
- 在 C++ 中，优先用 **`const`**、**`inline`** 和 **模板** 来替代宏

### 内联子程序

- **谨慎使用 `inline`**：只有在性能分析表明确实需要时才使用
- `inline` 违背了封装原则（调用方需要看到实现），应尽量避免过度使用

---

<aside>
📌

**核心要点**：好的子程序以**功能内聚**为目标，名字应清晰描述其职责。参数按"输入→修改→输出"排列，数量控制在 7 个以内。长度上限约 200 行，但比长度更重要的是内聚性和可读性。创建子程序最根本的理由是**降低复杂度**和**提高可读性**。

</aside>

## 7.8 核对表：高质量的子程序

### 大局事项

- [ ]  创建子程序的理由充分吗？
- [ ]  一个子程序中所有适于单独提出的部分是不是已经被提出到单独的子程序中了？
- [ ]  过程的名字中是否用了强烈、清晰的“动词+宾语”词组？函数的名字是否描述了其返回值？
- [ ]  子程序的名字是否描述了它所做的全部事情？
- [ ]  是否给常用的操作建立了命名规则？
- [ ]  子程序是否具有强烈的功能上的内聚性？即它是否做且只做一件事，并且把它做得很好？
- [ ]  子程序之间是否有较松的耦合？子程序与其他子程序之间的连接是否是小的(small)、明确的(intimate)、可见的(visible)和灵活的(flexible)？
- [ ]  子程序的长度是否是由其功能和逻辑自然确定，而非遵循任何人为的编码标准？

### 参数传递事宜

- [ ]  整体来看，子程序的参数表是否表现出一种具有整体性且一致的接口抽象？
- [ ]  子程序参数的排列顺序是否合理？是否与类似的子程序的参数排列顺序相符？
- [ ]  接口假定是否已在文档中说明？
- [ ]  子程序的参数个数是否没超过 7 个？
- [ ]  是否用到了每一个输入参数？
- [ ]  是否用到了每一个输出参数？
- [ ]  子程序是否避免了把输入参数用做工作变量？
- [ ]  如果子程序是一个函数，那么它是否在所有可能的情况下都能返回一个合法的值？