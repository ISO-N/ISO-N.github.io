---
title: 第3章 三思而后行：前期准备
date: 2026-02-17 15:24:54
categories:
- [软件工程, 理论]
tags:
- 代码大全
---
本章核心观点：在构建（编码）开始之前，做好充分的前期准备工作可以大幅降低项目风险和返工成本。

## 3.1 前期准备的重要性

- 项目的成败在构建开始之前就已经在很大程度上决定了
- 缺陷发现得越早，修复成本越低；需求阶段的错误到构建阶段修复，成本是原来的 **20~100 倍**
- 调试和相关返工占据了典型软件开发周期约 **50%** 的时间
- 关注前期准备并不意味着必须采用瀑布模型，迭代方法同样需要前期准备
- 程序员的职责之一是向上级和同事宣传前期准备的重要性（克服 "WIMP 综合征"——Why Isn't Mary Programming?）

## 3.2 确定你所从事的软件类型

不同类型的项目需要不同程度的前期准备：

- **商业系统**：倾向于迭代、非正式的方法
- **使命关键型系统**：需要更正式的规划
- **嵌入式生命关键型系统**：需要顺序、正式、高度审查的流程

### 选择顺序式（瀑布）方法的场景

- 需求相当稳定
- 设计直接明了且被充分理解
- 开发团队熟悉应用领域
- 项目风险较小
- 长期可预测性很重要
- 下游变更成本高

### 选择迭代式方法的场景

- 需求不明确或预期不稳定
- 设计复杂且具有挑战性
- 开发团队不熟悉应用领域
- 项目风险较大
- 长期可预测性不太重要
- 下游变更成本较低

### 实践建议

- 顺序式：预先定义约 **80%** 的需求，预留时间处理后续需求变更
- 迭代式：预先明确最重要的 **20%** 需求，以小增量方式逐步开发

## 3.3 问题定义前提条件

- 构建之前的第一个前提条件是对系统要解决的 **问题** 的清晰陈述
- 问题定义不应包含任何解决方案的暗示，它应该听起来像一个问题
- ✅ 好的问题定义："我们跟不上产品 X 的订单处理速度"
- ❌ 差的问题定义："我们需要优化自动数据录入系统以跟上产品 X 的订单"（这听起来像是解决方案）
- 问题定义应使用 **用户语言**，从用户角度描述
- 没有好的问题定义 → 可能花大量时间解决 **错误的问题**，这是双重惩罚（既没解决对的问题，又浪费了时间）

### 软件开发过程的层次

1. 问题定义
2. 需求
3. 架构
4. 构建
5. 系统测试
6. 后续改进

## 3.4 需求前提条件

- 需求详细描述软件系统 **应该做什么**，是走向解决方案的第一步

### 为什么需要明确的需求

- 确保 **用户** 而非程序员驱动系统功能
- 避免程序员猜测用户想要什么
- 帮助解决程序员之间关于程序行为的争论
- 最小化开发开始后的系统变更

### 需求不稳定的现实

- 稳定的需求是软件开发的圣杯，但并不存在
- 典型项目在开发过程中会经历约 **25%** 的需求变更
- 这导致了项目 **70%~85%** 的返工量

### 应对需求变更的策略

- 如果需求不够好，**停下来** 先把需求做对
- 让所有人了解需求变更的 **代价**（提及"日程"和"成本估算"通常能将"必须有"变成"最好有"）
- 建立正式的 **变更控制委员会** 来审查变更提议
- 使用 **演化式原型** 方法探索需求：构建一点 → 获取反馈 → 调整设计 → 继续构建
- 如果需求极其糟糕且不稳定，考虑 **放弃项目**

## 3.5 架构前提条件

- 软件架构是软件设计的 **高层部分**，是承载更细节设计的框架
- 架构的质量决定了系统的 **概念完整性**，进而决定了系统的最终质量
- 好的架构使构建变得容易，坏的架构使构建几乎不可能

### 典型架构组件

#### 程序组织

- 需要一个总体概览来广泛描述整个系统
- 定义程序中的主要构造块（类或子系统）
- 每个构造块应只有 **一个明确定义的职责**
- 各构造块之间应尽量少地了解彼此
- 应记录备选方案及选择当前方案的理由（设计依据与设计本身同样重要）

#### 主要的类

- 架构应指定要使用的主要类及其职责和交互方式
- 遵循 **80/20 法则**：指定占系统 80% 行为的 20% 的类

#### 数据设计

- 描述主要的文件和表设计，并说明选择的理由
- 数据通常只应通过 **访问类或例程** 以受控和抽象的方式被访问

#### 业务规则

- 如果架构依赖特定的业务规则，应识别它们并描述对系统设计的影响

#### 用户界面设计

- 架构应模块化，使得更换新 UI 不影响业务规则和输出部分

#### 输入/输出

- 指定预读、回顾还是即时读取方案
- 描述 I/O 错误检测的级别

#### 资源管理

- 描述管理有限资源（数据库连接、线程、句柄）的计划

#### 安全性

- 描述设计层和代码层的安全方法
- 编码规范应考虑安全性（缓冲区处理、不可信数据处理、加密等）

#### 性能

- 性能目标应同时包括 **速度** 和 **内存使用**
- 如果某些区域有性能风险，架构应明确指出

#### 可伸缩性

- 描述系统如何应对用户数、服务器数、数据库大小、事务量等的增长

#### 互操作性

- 描述系统如何与其他软件或硬件共享数据或资源

#### 国际化/本地化

- 国际化（I18N）：准备程序支持多个区域设置
- 本地化（L10N）：翻译程序以支持特定语言
- 架构应明确字符串和字符集的处理策略

#### 错误处理

- 约 **90%** 的程序代码用于异常和错误处理，仅 **10%** 用于正常情况
- 应在架构层面制定一致的错误处理策略
- 关键问题：纠正性还是检测性？主动还是被动？如何传播错误？错误消息的规范？在哪一层处理？各类对输入数据验证的职责？

#### 容错

- 架构应说明预期的容错水平（检测错误、恢复、控制不良影响）

#### 架构可行性

- 架构应证明系统在技术上是可行的
- 高风险区域应在全面构建开始前通过概念验证原型或调研来解决

#### 过度工程

- 软件中链条的强度不是取决于最弱的一环，而是 **所有弱环相乘**
- 架构应明确指出程序员是应偏向过度工程还是做最简单可行的方案

#### 购买 vs. 自建

- 最彻底的方案是根本不构建——而是 **购买**现成组件
- 如果不使用现成组件，架构应解释自建组件在哪些方面优于现成方案

#### 变更策略

- 架构应清楚描述处理变更的策略
- 最可能的增强功能应同时也是最容易实现的

## 3.6 花在前期准备上的时间

- 运作良好的项目将约 **10%~20%** 的精力和 **20%~30%** 的时间表投入需求、架构和前期规划
- 如果需求不稳定，将需求工作视为 **独立项目**，完成后再估算其余项目时间
- 架构工作同理——如果是全新领域，预留更多时间应对不确定性

## 要点总结

- 前期准备的首要目标是 **降低风险**
- 高质量软件的注意力应从开发过程的 **开头贯穿到结尾**，开头的质量关注比结尾的影响更大
- 程序员的职责之一是向上级和同事宣传前期准备的重要性
- 项目类型显著影响构建前提条件——许多项目应高度迭代，有些则应更偏顺序式
- 没有好的问题定义 → 可能解决错误的问题
- 没有好的需求 → 可能遗漏问题的重要细节（构建后修改需求的成本是前期的 20~100 倍）
- 没有好的架构 → 可能以错误的方式解决正确的问题

# 核对表：需求

> 这张需求核对表包含了一系列的问题——问问自己项目的需求工作做得如何。本书并不会告诉你如何做出好的需求分析，所以列表里面也不会有这样的问题。在开始构建之前，用这份列表做一次“心智健全”检查，看看你的地基到底有多坚固——用“需求里氏震级”来衡量。
> 

> 并不是核对表中所有的问题都适用于你的项目。如果你做的是一个非正式项目，那么你会发现有些东西根本就不需要考虑。你还会发现一些问题你需要考虑，但不需要做出正式的回答。如果你在做一个大型的、正式的项目，你也许就要逐条考虑了。
> 

### 针对功能需求

- [ ]  是否详细定义了系统的全部输入，包括其来源、精度、取值范围、出现频率等？
- [ ]  是否详细定义了系统的全部输出，包括目的地、精度、取值范围、出现频率、格式等？
- [ ]  是否详细定义了所有输出格式（Web 页面、报表，等等）？
- [ ]  是否详细定义了所有硬件及软件的外部接口？
- [ ]  是否详细定义了全部外部通信接口，包括握手协议、纠错协议、通信协议等？
- [ ]  是否列出了用户想要做的全部事情？
- [ ]  是否详细定义了每个任务所用的数据，以及每个任务得到的数据？

### 针对非功能需求（质量需求）

- [ ]  是否为全部必要的操作，从用户的视角，详细描述了期望响应时间？
- [ ]  是否详细描述了其他与计时有关的考虑，例如处理时间、数据传输率、系统吞吐量？
- [ ]  是否详细定义了安全级别？
- [ ]  是否详细定义了可靠性，包括软件失灵的后果、发生故障时需要保护的至关重要的信息、错误检测与恢复的策略等？
- [ ]  是否详细定义了机器内存和剩余磁盘空间的最小值？
- [ ]  是否详细定义了系统的可维护性，包括适应特定功能的变更、操作环境的变更、与其他软件的接口的变更能力？
- [ ]  是否包含对“成功”的定义？“失败”的定义呢？

### 需求的质量

- [ ]  需求是用用户的语言书写的吗？用户也这么认为吗？
- [ ]  每条需求都不与其他需求冲突吗？
- [ ]  是否详细定义了相互竞争的特性之间的权衡——例如，健壮性与正确性之间的权衡？
- [ ]  是否避免在需求中规定设计（方案）？
- [ ]  需求是否在详细程度上保持相当一致的水平？有些需求应该更详细地描述吗？有些需求应该更粗略地描述吗？
- [ ]  需求是否足够清晰，即使转交给一个独立的小组去构建，他们也能理解吗？开发者也这么想吗？
- [ ]  每个条款都与待解决的问题及其解决方案相关吗？能从每个条款上溯到它在问题域中对应的根源吗？
- [ ]  是否每条需求都是可测试的？是否可能进行独立的测试，以检验满足各项需求？
- [ ]  是否详细描述了所有可能的对需求的改动，包括各项改动的可能性？

### 需求的完备性

- [ ]  对于在开始开发之前无法获得的信息，是否详细描述了信息不完全的区域？
- [ ]  需求的完备度是否能达到这种程度：如果产品满足所有需求，那么它就是可接受的？
- [ ]  你对全部需求都感到很舒服吗？你是否已经去掉了那些不可能实现的需求——那些只是为了安抚客户和老板的东西？

# 核对表：架构

> 以下是一份问题列表，优秀的架构应该关注这些问题。这张核对表的意图并非用做一份有关如何做架构的完全指南，而是作为一种实用的评估手段，用来评估软件食物链到了程序员这一头还有多少营养成分。这张核对表可用做你自己的核对表的出发点。就像“需求”的核对表一样，如果你从事的是非正式项目，那么你会发现其中某些条款甚至都不用去想。如果你从事的是更大型的项目，那么大多数条款都会是很有用的。
> 

### 针对各架构主题

- [ ]  程序的整体组织结构是否清晰？是否包含一个良好的架构全局观（及其理由）？
- [ ]  是否明确定义了主要的构造块（包括每个构造块的职责范围及与其他构造块的接口）？
- [ ]  是否明显涵盖了“需求”中列出的所有功能（每个功能对应的构造块不太太多也不太少）？
- [ ]  是否描述并论证了那些最关键的类？
- [ ]  是否描述并论证了数据设计？
- [ ]  是否详细定义了数据库的组织结构和内容？
- [ ]  是否指出了所用关键的业务规则，并描述其对系统的影响？
- [ ]  是否描述了用户界面设计的策略？
- [ ]  是否将用户界面模块化，使界面的变更不会影响程序其余部分？
- [ ]  是否描述并论证了处理 I/O 的策略？
- [ ]  是否估算了稀缺资源（如线程、数据库连接、句柄、网络带宽等）的使用量，是否描述并论证了资源管理的策略？
- [ ]  是否描述了架构的安全需求？
- [ ]  架构是否为每个类、每个子系统、或每个功能域(functionality area)提出空间与时间预算？
- [ ]  架构是否描述了如何达到可伸缩性？
- [ ]  架构是否关注互操作性？
- [ ]  是否描述了国际化/本地化的策略？
- [ ]  是否提供了一套内聚的错误处理策略？
- [ ]  是否规定了容错的办法（如果需要）？
- [ ]  是否证实了系统各个部分的技术可行性？
- [ ]  是否详细描述了过度工程(overengineering)的方法？
- [ ]  是否包含了必要的“买 vs. 造”的决策？
- [ ]  架构是否描述了如何加工被复用的代码，使之符合其他架构目标？
- [ ]  是否将架构设计得能够适应很可能出现的变更？

### 架构的总体质量

- [ ]  架构是否解决了全部需求？
- [ ]  有没有哪个部分是“过度架构/overarchitected”或“欠架构/underarchitected”？是否明确宣布了在这方面的预期指标？
- [ ]  整个架构是否在概念上协调一致？
- [ ]  顶层设计是否独立于用作实现它的机器和语言？
- [ ]  是否说明了所有主要的决策的动机？
- [ ]  你，作为一名实现该系统的程序员，是否对这个架构感觉良好？

# 核对表：前期准备

- [ ]  你是否辨明了自己所从事的软件的类型，并对所用的开发方法做出相应的剪裁？
- [ ]  是否充分明确地定义了需求？而且需求足够稳定，能开始构建了？（详见需求核对表。）
- [ ]  是否充分明确地定义了架构，以便开始构建？（详见架构核对表。）
- [ ]  是否已经指出你的（当前）项目中独有的风险（以避免构建活动面临不必要的风险）？