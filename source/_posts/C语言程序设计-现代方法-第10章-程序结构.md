---
title: 第10章 程序结构
date: 2026-02-17 02:20:25
categories:
- [编程技术, C]
tags:
- C语言程序设计-现代方法
---
## 10.1 局部变量

### 什么是局部变量

在函数体内声明的变量称为**局部变量**（local variable），也叫**自动变量**（automatic variable）：

```c
void func(void) {
    int x = 10;      // x 是局部变量
    double y = 3.14;  // y 也是局部变量
}
```

- 局部变量具有**自动存储期**：函数调用时创建，函数返回时销毁
- 局部变量具有**块作用域**：只在声明它的函数（或块）内可见

### 静态局部变量

在局部变量前加 `static` 关键字，变量在程序执行期间**一直存在**，不会在函数返回时销毁：

```c
void count_calls(void) {
    static int count = 0;  // 只在第一次调用时初始化
    count++;
    printf("Called %d times\n", count);
}
```

<aside>
💡

`static` 局部变量的初始化**只执行一次**（程序启动时），后续调用保留上一次的值。未显式初始化时默认为 **0**。

</aside>

### 形式参数

函数的形式参数本质上也是局部变量，唯一区别是在**函数调用时自动被初始化**（由实参赋值）：

```c
int sum(int a, int b) {   // a, b 是形参，也是局部变量
    return a + b;
}
```

## 10.2 外部变量

### 什么是外部变量

在所有函数**外部**声明的变量称为**外部变量**（external variable），也叫**全局变量**：

```c
int total = 0;           // 外部变量，所有函数都可以访问

void add(int x) {
    total += x;          // 直接使用外部变量
}

void print_total(void) {
    printf("%d\n", total);
}
```

- 外部变量具有**静态存储期**：程序开始时创建，程序结束时销毁
- 外部变量具有**文件作用域**：从声明处到文件末尾都可见
- 未显式初始化时默认为 **0**

### 外部变量的优缺点

<aside>
⚠️

**尽量少用外部变量！** 虽然方便，但外部变量会带来许多问题：

- 难以维护：任何函数都可能修改外部变量，难以追踪变化
- 命名冲突：外部变量名可能与局部变量名冲突
- 复用性差：使用外部变量的函数难以在其他程序中复用
</aside>

### 何时使用外部变量

外部变量适合以下场景：

- 多个函数需要**共享数据**，且通过参数传递过于繁琐
- 使用 `const` 修饰的**全局常量**

```c
const double PI = 3.14159265358979;  // 全局常量，合理使用
```

## 10.3 程序块

### 块（Block）

复合语句 `{ }` 内部可以包含声明和语句，构成一个**块**（block）：

```c
if (x > 0) {
    int temp = x;     // temp 的作用域仅限于此块
    x = y;
    y = temp;
}
// temp 在此处不可见
```

- 块内声明的变量在**块结束时销毁**
- 块可以嵌套，内层块的变量会**隐藏**（shadow）外层同名变量

```c
int x = 10;
{
    int x = 20;        // 隐藏外层的 x
    printf("%d\n", x); // 输出 20
}
printf("%d\n", x);     // 输出 10（外层的 x 未受影响）
```

<aside>
⚠️

变量隐藏容易导致**混淆和错误**，应尽量避免在内层块中使用与外层相同的变量名。

</aside>

## 10.4 作用域

### 作用域规则

C 语言中每个变量都有**作用域**（scope），即变量可见的程序区域：

| 变量类型 | 作用域 | 存储期 |
| --- | --- | --- |
| 局部变量 | 从声明处到所在块的末尾 | 自动（函数返回时销毁） |
| `static` 局部变量 | 从声明处到所在块的末尾 | 静态（程序结束时销毁） |
| 外部变量 | 从声明处到文件末尾 | 静态（程序结束时销毁） |
| 形式参数 | 整个函数体 | 自动（函数返回时销毁） |

<aside>
📌

注意 `static` 局部变量：它的**作用域**仍然是局部的（只在函数内可见），但**存储期**是静态的（值会保留到下次调用）。作用域和存储期是**两个独立的概念**。

</aside>

### 名字查找规则

当程序中出现一个变量名时，编译器从**最内层作用域**向外查找：

```c
int x = 1;                 // 文件作用域

void func(void) {
    int x = 2;             // 函数作用域，隐藏外层 x
    {
        int x = 3;         // 块作用域，隐藏函数层 x
        printf("%d\n", x); // 输出 3
    }
    printf("%d\n", x);     // 输出 2
}
```

## 10.5 构建 C 程序

### 程序的典型组织结构

一个 C 源文件通常按以下顺序组织：

```c
/* 1. #include 指令 */
#include <stdio.h>
#include <stdlib.h>

/* 2. #define 指令 */
#define MAX_SIZE 100

/* 3. 类型定义 */
typedef int Bool;

/* 4. 外部变量的声明 */
int total;

/* 5. 函数原型（除 main 以外的函数） */
void read_input(void);
void process_data(void);
void print_results(void);

/* 6. main 函数的定义 */
int main(void) {
    read_input();
    process_data();
    print_results();
    return 0;
}

/* 7. 其他函数的定义 */
void read_input(void) { /* ... */ }
void process_data(void) { /* ... */ }
void print_results(void) { /* ... */ }
```

### 函数原型的重要性

在调用函数之前，编译器需要知道函数的**返回类型**和**参数类型**。有两种方式：

1. **将函数定义放在调用之前**——但大型程序中难以做到
2. **提供函数原型**（推荐）——在文件顶部声明所有函数

```c
// 函数原型
double average(double a, double b);

int main(void) {
    double avg = average(3.0, 5.0);  // 编译器知道参数和返回类型
    return 0;
}

double average(double a, double b) {
    return (a + b) / 2;
}
```

<aside>
⚠️

如果没有函数原型，C89 会假设函数返回 `int` 并且不检查参数类型，这可能导致**难以发现的错误**。C99/C11 要求在调用前必须有函数原型或定义。

</aside>

### 良好的程序组织建议

- 将**相关的函数**放在一起
- 函数原型放在文件**顶部**，便于查看接口
- 外部变量的声明放在使用它的函数**之前**
- 每个函数前加**注释**说明用途、参数和返回值

> 本章核心：理解**局部变量**与**外部变量**的区别，掌握**作用域**与**存储期**两个独立概念，养成良好的**程序组织**习惯。尽量减少外部变量的使用，保持函数的独立性和可复用性。
>