---
title: 第25章 代码调整策略
date: 2026-02-17 15:25:12
categories:
- [软件工程, 理论]
tags:
- 代码大全
---
代码调整（code tuning）是指为了提高代码运行速度或减少资源占用而对代码进行的**小规模修改**。它是性能优化手段之一，但绝非唯一手段，也不应该是第一手段。本章的核心观点：**在动手调整代码之前，先确认你真的需要这样做，并且用数据说话。**

---

## 25.1 性能概述

### 质量特性与性能的关系

- 性能只是软件质量的**众多特性之一**（还有正确性、可用性、可读性、可维护性等）
- 为了性能而牺牲代码的可读性和可维护性，往往得不偿失
- 用户感知到的"性能"通常与**响应时间**和**吞吐量**有关，而这些未必需要通过代码调整来改善

### 性能与代码调整

- 代码调整 ≠ 性能优化的全部
- 性能问题可能来自**架构设计**、**算法选择**、**数据结构**、**硬件**、**编译器设置**等多个层面
- 在微观层面调整代码之前，先从宏观层面思考

<aside>
💡

**不要把"代码调整"等同于"性能优化"。** 性能优化是一个更广泛的概念，而代码调整只是其中最底层、最微观的手段。

</aside>

## 25.2 性能优化简介

### 程序需求层面

- 在需求阶段就明确性能目标（如"页面加载时间 < 2 秒"）
- 如果性能需求不明确，就没有优化的依据，也无法衡量是否"够快"

### 程序设计层面

- **架构设计**对性能的影响远大于代码调整
- 例如：选择 C/S 架构还是 B/S 架构、数据库的选型、缓存策略等
- 在设计阶段就考虑性能目标，比事后调整代码高效得多

### 类和子程序设计层面

- 选择合适的**数据结构和算法**是最重要的优化手段
- 将 O(n²) 的算法替换为 O(n log n) 的算法，效果远超任何微观调整
- 良好的类设计使得后续优化更容易，因为修改被**封装**在类内部

### 操作系统层面

- 操作系统的调度策略、内存管理、I/O 策略等都会影响性能
- 有时候换一个操作系统设置就能解决问题

### 代码编译层面

- 打开编译器优化选项（如 `-O2`、`-O3`）通常是**最省力**的性能改善方式
- 现代编译器的优化能力非常强，很多手工调整编译器能自动完成
- 换一个更好的编译器有时候比调整代码更有效

### 硬件层面

- 有时候，升级硬件比花大量时间优化代码**更经济**
- 程序员的时间比 CPU 的时间贵得多

<aside>
⚠️

**在每个层面都问自己：这个层面的优化够了吗？** 只有当高层面的优化空间用尽后，才应该下沉到代码调整层面。

</aside>

## 25.3 蜜糖和哥斯拉

### 常见的性能直觉谬误

本章的一个核心洞见：**程序员对性能的直觉几乎总是错的。**

- **"高级语言的代码比低级语言慢"** → 不一定。现代编译器优化后，高级语言的性能差距可能很小
- **"某个操作肯定很慢"** → 不测量就不知道。不同平台、编译器、运行时环境下结果可能完全不同
- **"减少代码行数就能提高速度"** → 代码行数和运行时间之间没有可靠的对应关系
- **"某些操作本来就比其他操作快"** → 实际性能取决于具体的语言、编译器和硬件环境

<aside>
🦖

**书中反复强调：没有经过测量的优化只是猜测。** 你以为的瓶颈往往不是真正的瓶颈，而你忽略的地方可能才是性能杀手。

</aside>

### 关于性能的几个反直觉事实

- 程序的大部分执行时间通常花在**一小部分代码**上（二八法则：80% 的时间花在 20% 的代码上，甚至更集中）
- 程序员在**没有测量数据**的情况下猜测瓶颈位置，错误率非常高
- 即使是经验丰富的程序员，对性能的直觉也不可靠

## 25.4 性能测量

### 为什么必须测量

- 性能的直觉不可靠 → 必须用**数据**替代直觉
- 不测量就不知道优化是否有效，甚至可能越"优化"越慢
- 性能问题的定位必须依赖 Profiler 等工具

### 测量的方法

- **性能分析器（Profiler）**：最重要的工具，能精确告诉你每个函数/代码块的执行时间和调用次数
- **手动计时**：用 `System.currentTimeMillis()`、`time.time()` 等在关键代码段前后计时
- **日志与监控**：在生产环境中收集性能数据

### 测量的原则

- **优化前先测量**：建立基准线（baseline），知道当前有多快/多慢
- **优化后再测量**：确认改动确实带来了改善
- **在目标环境中测量**：开发环境和生产环境的性能表现可能截然不同
- **每次只改一个地方**：否则无法判断是哪个改动带来了效果

## 25.5 迭代

### 迭代优化的流程

1. **用 Profiler 识别热点代码**（消耗最多时间的地方）
2. **针对热点进行代码调整**
3. **测量调整后的效果**
4. **如果未达标，回到第 1 步继续迭代**
5. **如果已达标，停止调整**

### 何时停止优化

- 已经**达到性能需求**时就停止——不要为了优化而优化
- 当优化带来的收益已经**微不足道**时停止
- 当继续优化会严重损害**代码可读性和可维护性**时停止

## 25.6 代码调整方法总结

### 系统化的代码调整步骤

1. **用设计良好、易于理解的代码开发程序**
2. 如果性能不达标——
    - a. **保存可运行的、正确的代码版本**（用版本控制）
    - b. **用 Profiler 测量系统**，找到热点
    - c. **判断性能瓶颈是否来自设计、数据结构/算法还是代码层面**
    - d. 针对"代码调整"层面的问题，在该热点代码中进行调整
    - e. **每次调整后都重新测量**
    - f. 如果调整没有改善性能，**恢复到之前的代码**（切勿保留无效的"优化"代码）

<aside>
🔑

**黄金法则：先让代码正确，再让代码快。** 一份正确但慢的程序远比一份快但错的程序有价值。可以让正确的程序变快，但很难让快的程序变正确。

</aside>

---

## 本章核心检查清单

- [ ]  是否在更高的层面（需求、架构、算法）寻找过优化机会，而不是直接跳到代码调整？
- [ ]  是否明确了**可量化的性能目标**？
- [ ]  是否使用了 **Profiler** 来定位真正的性能瓶颈，而不是凭直觉猜测？
- [ ]  是否在优化**前后都进行了测量**，用数据确认效果？
- [ ]  是否每次只做一处修改，以便准确归因？
- [ ]  如果优化无效，是否**回滚了代码**而不是保留无用的"优化"？
- [ ]  是否考虑过**编译器优化**选项作为替代方案？
- [ ]  是否在性能达标后就**停止了优化**，而没有过度优化？
- [ ]  是否确保优化后的代码仍然**正确且可读**？

---

## 要点总结

> **代码调整是性能优化的最后手段，而非第一手段。** 在动手修改代码之前，先从需求、架构、算法、编译器等更高层面寻找优化空间。如果确实需要调整代码，必须以**测量数据**为依据：用 Profiler 找到真正的热点，每次只改一处，改后必测，无效则回滚。永远记住：**先让代码正确、可读，再追求性能。** 没有数据支撑的优化不是优化，而是赌博。
>