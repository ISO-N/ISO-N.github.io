---
title: 第26章 代码调整技术
date: 2026-02-17 15:25:12
categories:
- [软件工程, 理论]
tags:
- 代码大全
---
## 📌 本章概览

第 26 章聚焦于**具体的代码调整技术**，是第 25 章"代码调整策略"的实操延续。书中通过大量基准测试数据，展示了在**逻辑、循环、数据变换、表达式、子程序**等层面可使用的性能优化手段，并反复强调：**任何调整都必须经过度量验证**，因为效果因语言、编译器和环境而异。

---

## 🔁 逻辑（Logic）

- **在知道答案后停止判断**：利用短路求值（short-circuit evaluation），将最可能为真/假的条件放在前面，尽早跳出判断。
- **按照出现频率排列 `if-else` 链**：把最常命中的分支放在最前，减少平均判断次数。
- **用查找表（Lookup Table）替代复杂的条件链**：将结果预存到数组或哈希表中，用索引直接获取，避免大量 `if-else` 或 `switch-case`。
- **使用惰性求值（Lazy Evaluation）**：推迟计算直到真正需要结果时才执行，避免不必要的开销。

---

## 🔄 循环（Loops）

- **将判断外提（Unswitching）**：如果循环内部有不随迭代变化的条件判断，将其移到循环外部，分成两个循环。
- **合并循环（Jamming / Fusion）**：将多个遍历同一范围的循环合并为一个，减少循环开销。
- **展开循环（Unrolling）**：将循环体复制多份以减少循环控制（判断和自增）的次数。适用于循环次数已知或可预估的场景。
- **减少内部工作量**：
    - 把与循环变量无关的计算提到循环外（**强度削减**）。
    - 用加法替代乘法（如 `i * k` 改为在每次迭代中累加 `k`）。
- **使用哨兵值（Sentinel Value）**：在搜索循环中，在数据末尾放置目标值作为哨兵，从而省去每次迭代的边界检查。
- **将最忙的循环放在最内层**：对于嵌套循环，让迭代次数最多的循环在内层，以减少外层循环的初始化和判断开销。

---

## 🔀 数据变换（Data Transformations）

- **使用整数而非浮点数**：整数运算通常比浮点运算快得多，如果精度允许，优先使用整数。
- **减少数组维度**：将多维数组降维为一维数组，手动计算索引，减少寻址开销。
- **最小化数组引用次数**：将频繁使用的数组元素赋值给临时变量，避免重复寻址。
- **使用辅助索引（Supplementary Indexes）**：
    - 为字符串长度添加额外字段，避免反复计算。
    - 为复杂数据结构创建独立的索引数组以加速访问。
- **使用缓存（Caching）**：将最近计算过的结果保存下来，下次需要时直接复用，适用于计算开销较大或访问模式有局部性的场景。

---

## ✨ 表达式（Expressions）

- **利用代数恒等式简化表达式**：例如用 `!a && !b` 替换 `!(a || b)`，或在数学计算中化简公式，减少运算步骤。
- **削弱运算强度（Strength Reduction）**：
    - 用加法替代乘法
    - 用乘法替代幂运算
    - 用位移替代乘除 2 的幂（如 `x >> 1` 代替 `x / 2`）
- **在编译时初始化常量**：将不变的值定义为编译期常量（`const`、`#define`），而非运行时计算。
- **小心系统子程序调用**：像 `log()`、`sqrt()` 等系统函数开销较大，可以考虑用近似计算或查找表代替。
- **使用正确的常量类型**：避免隐式类型转换，例如浮点比较时使用 `2.0` 而非 `2`。
- **预计算结果**：对于在运行时重复计算的表达式，提前计算好并存储起来。
- **消除公共子表达式**：如果同一个子表达式在多处出现，将其计算结果赋给变量后复用。

---

## 📞 子程序（Routines）

- **将函数重写为内联（Inline）**：对于非常短小且频繁调用的子程序，可考虑内联展开以消除调用开销。但需注意可读性和可维护性的权衡。
- 现代编译器在大多数情况下会自动做内联优化，手动内联的必要性已大大降低。

---

## ⚙️ 用低级语言重编码

- 当高层语言的优化已达极限，可以将**性能热点**部分用汇编或更低级语言改写。
- 推荐做法：
    1. 先用高级语言写出正确且可读的代码
    2. 用性能分析工具找到瓶颈
    3. 仅对瓶颈部分用低级语言重写
    4. 保留高级语言版本作为注释和文档

---

## ⚠️ 代码调整的注意事项

<aside>
⚡

**度量、度量、再度量！** 书中反复强调，每一项调整的效果都必须经过实际基准测试来验证。不同语言、编译器、硬件平台的结果可能截然不同，切勿凭直觉假设某种优化一定有效。

</aside>

- **一次只改一处**：每次只做一项调整并度量，以便准确判断效果。
- **如果调整没有带来改善，就撤销它**：无效的优化只会增加代码复杂度。
- **可读性优先**：只有在确认性能瓶颈且调整显著有效的情况下，才牺牲可读性。牺牲可读性时，要写好注释说明原因。

---

## 🗝️ 核心要点速记

| 调整领域 | 关键手段 |
| --- | --- |
| **逻辑** | 短路求值、按频率排列分支、查找表 |
| **循环** | 外提判断、合并循环、展开循环、哨兵值 |
| **数据** | 整数替代浮点、降维数组、缓存结果 |
| **表达式** | 强度削减、预计算、消除公共子表达式 |
| **子程序** | 内联展开（需权衡可读性） |
| **低级语言** | 仅对热点部分重编码，保留高级语言版本 |