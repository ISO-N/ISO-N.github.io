---
title: 第23章 库对数值和字符数据的支持
date: 2026-02-17 02:20:33
categories:
- [编程技术, C]
---
## 23.1 <float.h>：浮点类型的特性

### 浮点类型的表示模型

C 语言的浮点数遵循如下模型（基于 IEEE 754 标准）：

$$
x = s \times b^e \times \sum_{k=1}^{p} f_k \times b^{-k}
$$

- $s$：符号（+1 或 -1）
- $b$：基数（通常为 2）
- $e$：指数
- $p$：精度（有效数字的位数）
- $f_k$：尾数的各个数字

### <float.h> 中的重要宏

`<float.h>` 定义了浮点类型（`float`、`double`、`long double`）的**特性宏**：

| 宏 | 含义 | 典型值（double） |
| --- | --- | --- |
| `FLT_RADIX` | 指数的基数 $b$ | 2 |
| `FLT_DIG` / `DBL_DIG` / `LDBL_DIG` | 十进制有效数字位数 | 15（double） |
| `FLT_EPSILON` / `DBL_EPSILON` | 1.0 与下一个可表示值的差 | 2.22e-16（double） |
| `FLT_MAX` / `DBL_MAX` | 最大有限正浮点数 | 1.80e+308（double） |
| `FLT_MIN` / `DBL_MIN` | 最小正规格化正浮点数 | 2.23e-308（double） |
| `FLT_MANT_DIG` / `DBL_MANT_DIG` | 尾数的位数 $p$（以 $b$ 为基数） | 53（double） |
| `FLT_MAX_EXP` / `DBL_MAX_EXP` | 最大指数 | 1024（double） |
| `FLT_MIN_EXP` / `DBL_MIN_EXP` | 最小指数 | -1021（double） |

<aside>
💡

`DBL_EPSILON` 常用于浮点数**近似相等**的判断：

```c
// 判断两个 double 是否"几乎相等"
if (fabs(a - b) < DBL_EPSILON * fabs(a))
    // 认为 a 和 b 相等
```

</aside>

## 23.2 <limits.h>：整数类型的大小

### 整数类型的范围宏

`<limits.h>` 定义了各种整数类型的**最小值和最大值**：

| 宏 | 含义 | 最低保证值 |
| --- | --- | --- |
| `CHAR_BIT` | 一个字节的位数 | 8 |
| `CHAR_MIN` / `CHAR_MAX` | char 的范围 | 取决于 char 的符号性 |
| `SCHAR_MIN` / `SCHAR_MAX` | signed char 的范围 | -127 / 127 |
| `UCHAR_MAX` | unsigned char 最大值 | 255 |
| `SHRT_MIN` / `SHRT_MAX` | short 的范围 | -32767 / 32767 |
| `USHRT_MAX` | unsigned short 最大值 | 65535 |
| `INT_MIN` / `INT_MAX` | int 的范围 | -32767 / 32767 |
| `UINT_MAX` | unsigned int 最大值 | 65535 |
| `LONG_MIN` / `LONG_MAX` | long 的范围 | -2147483647 / 2147483647 |
| `ULONG_MAX` | unsigned long 最大值 | 4294967295 |

<aside>
📌

这些值是 C 标准规定的**最低保证值**，实际实现通常更大。例如大多数现代平台上 `INT_MAX` 为 2147483647（32 位）。

</aside>

### 使用场景

```c
#include <limits.h>

// 检查加法是否溢出
if (a > 0 && b > INT_MAX - a) {
    printf("溢出！\n");
}

// 初始化最小值/最大值
int min = INT_MAX;
int max = INT_MIN;
for (int i = 0; i < n; i++) {
    if (arr[i] < min) min = arr[i];
    if (arr[i] > max) max = arr[i];
}
```

## 23.3 <math.h>：数学计算

### 错误处理

`<math.h>` 中的函数在出错时有两种行为：

- **定义域错误**（domain error）：参数超出数学定义范围（如 `sqrt(-1)`），`errno` 设为 `EDOM`，返回值由实现定义
- **取值范围错误**（range error）：结果太大无法表示（如 `exp(1000)`），`errno` 设为 `ERANGE`，返回 `HUGE_VAL`（或其负值）

```c
#include <math.h>
#include <errno.h>

errno = 0;
double y = sqrt(-1.0);
if (errno == EDOM)
    printf("定义域错误！\n");
```

### 三角函数

| 函数 | 说明 | 参数/返回值 |
| --- | --- | --- |
| `sin(x)` / `cos(x)` / `tan(x)` | 正弦 / 余弦 / 正切 | 参数为弧度 |
| `asin(x)` / `acos(x)` / `atan(x)` | 反正弦 / 反余弦 / 反正切 | 返回弧度 |
| `atan2(y, x)` | 计算 $y/x$ 的反正切 | 返回 $(-\pi, \pi]$ |

```c
double angle = 45.0;
double rad = angle * 3.14159265 / 180.0;  // 角度转弧度
printf("sin(45°) = %.4f\n", sin(rad));     // 0.7071
```

<aside>
📌

`atan2(y, x)` 比 `atan(y/x)` 更好用：它能正确处理 $x = 0$ 的情况，并且返回值覆盖完整的 $(-\pi, \pi]$ 范围。

</aside>

### 双曲函数

| 函数 | 说明 |
| --- | --- |
| `sinh(x)` / `cosh(x)` / `tanh(x)` | 双曲正弦 / 双曲余弦 / 双曲正切 |

### 指数与对数函数

| 函数 | 说明 |
| --- | --- |
| `exp(x)` | $e^x$ |
| `log(x)` | 自然对数 $ln(x)$，$x > 0$ |
| `log10(x)` | 以 10 为底的对数 $log_{10}(x)$，$x > 0$ |

```c
printf("e^2 = %.4f\n", exp(2));       // 7.3891
printf("ln(10) = %.4f\n", log(10));   // 2.3026
printf("log10(1000) = %.1f\n", log10(1000));  // 3.0
```

### 幂函数

| 函数 | 说明 |
| --- | --- |
| `pow(x, y)` | $x^y$ |
| `sqrt(x)` | $sqrt{x}$，$x geq 0$ |

<aside>
⚠️

`pow` 函数的参数和返回值都是 `double`。对于**整数幂运算**，手写循环通常比 `pow` 更快且更精确：

```c
// 不推荐（可能有精度问题）
int result = (int)pow(2, 10);

// 推荐（整数运算，精确）
int result = 1 << 10;   // 位移代替 2 的幂
```

</aside>

### 就近取整、截断和取余函数

| 函数 | 说明 | 示例 |
| --- | --- | --- |
| `ceil(x)` | 向上取整（天花板） | `ceil(2.3)` → 3.0 |
| `floor(x)` | 向下取整（地板） | `floor(2.7)` → 2.0 |
| `fabs(x)` | 绝对值 | `fabs(-3.5)` → 3.5 |
| `fmod(x, y)` | 浮点取余 | `fmod(5.5, 2.0)` → 1.5 |

### 操纵浮点数的函数

| 函数 | 说明 |
| --- | --- |
| `frexp(x, &exp)` | 将 $x$ 拆分为尾数 $f$ 和指数 $n$，使 $x = f times 2^n$，$0.5 leq |f| < 1$ |
| `ldexp(x, exp)` | 计算 $x \times 2^{exp}$ |
| `modf(x, &ipart)` | 将 $x$ 拆分为整数部分和小数部分 |

```c
int exp;
double frac = frexp(12.0, &exp);
// frac = 0.75, exp = 4  →  12.0 = 0.75 × 2^4

double ipart;
double fpart = modf(3.14, &ipart);
// ipart = 3.0, fpart = 0.14
```

## 23.4 <ctype.h>：字符处理

### 字符分类函数

`<ctype.h>` 提供了一组用于**测试字符类别**的函数，参数为 `int`（接受 `unsigned char` 或 `EOF`），返回非零表示真：

| 函数 | 测试条件 |
| --- | --- |
| `isalpha(c)` | 字母（a-z, A-Z） |
| `isdigit(c)` | 数字（0-9） |
| `isalnum(c)` | 字母或数字 |
| `isupper(c)` | 大写字母 |
| `islower(c)` | 小写字母 |
| `isspace(c)` | 空白字符（空格、`\t`、`\n`、`\v`、`\f`、`\r`） |
| `ispunct(c)` | 标点符号（可打印但非空格且非字母数字） |
| `isprint(c)` | 可打印字符（包括空格） |
| `isgraph(c)` | 可打印字符（不包括空格） |
| `iscntrl(c)` | 控制字符 |
| `isxdigit(c)` | 十六进制数字（0-9, a-f, A-F） |

```c
#include <ctype.h>

// 统计字符串中字母和数字的个数
int letters = 0, digits = 0;
for (int i = 0; s[i] != '\0'; i++) {
    if (isalpha(s[i])) letters++;
    else if (isdigit(s[i])) digits++;
}
```

<aside>
💡

使用 `<ctype.h>` 函数比手写范围判断（如 `c >= 'a' && c <= 'z'`）更**可移植**，因为不是所有字符集都像 ASCII 那样字母连续排列。

</aside>

### 字符大小写转换函数

| 函数 | 说明 |
| --- | --- |
| `toupper(c)` | 如果 `c` 是小写字母，返回对应大写字母；否则返回 `c` 本身 |
| `tolower(c)` | 如果 `c` 是大写字母，返回对应小写字母；否则返回 `c` 本身 |

```c
// 将字符串转为大写
for (int i = 0; s[i] != '\0'; i++)
    s[i] = toupper(s[i]);
```

## 23.5 <string.h>：字符串处理

### 复制函数

| 函数 | 说明 |
| --- | --- |
| `strcpy(s1, s2)` | 将 `s2`（含 `\0`）复制到 `s1`，返回 `s1` |
| `strncpy(s1, s2, n)` | 最多复制 `n` 个字符。若 `s2` 长度不足 `n`，用 `\0` 填充 |

```c
char dest[20];
strcpy(dest, "Hello");          // dest = "Hello"
strncpy(dest, "Hello World!", 5);
dest[5] = '\0';                 // 必须手动加 \0！dest = "Hello"
```

<aside>
⚠️

`strncpy` 有两个陷阱：

- 如果 `s2` 长度 ≥ `n`，结果**不会自动添加** `\0`，必须手动补
- 如果 `s2` 长度 < `n`，会用 `\0` 填满剩余空间，这在大缓冲区上可能影响性能
</aside>

### 拼接函数

| 函数 | 说明 |
| --- | --- |
| `strcat(s1, s2)` | 将 `s2` 追加到 `s1` 末尾，返回 `s1` |
| `strncat(s1, s2, n)` | 最多追加 `n` 个字符，**始终添加** `\0` |

```c
char s[20] = "Hello";
strcat(s, " World");     // s = "Hello World"
strncat(s, "!!!", 1);    // s = "Hello World!"
```

<aside>
📌

`strncat` 比 `strncpy` 更安全：它**总会**在结果末尾添加 `\0`。

</aside>

### 比较函数

| 函数 | 说明 |
| --- | --- |
| `strcmp(s1, s2)` | 按字典序比较，返回 < 0、0 或 > 0 |
| `strncmp(s1, s2, n)` | 最多比较前 `n` 个字符 |

```c
if (strcmp(s1, s2) == 0)
    printf("字符串相等\n");

if (strncmp(s1, "http", 4) == 0)
    printf("以 http 开头\n");
```

### 搜索函数

| 函数 | 说明 |
| --- | --- |
| `strchr(s, c)` | 在 `s` 中查找字符 `c` **第一次**出现的位置 |
| `strrchr(s, c)` | 在 `s` 中查找字符 `c` **最后一次**出现的位置 |
| `strstr(s1, s2)` | 在 `s1` 中查找子串 `s2` 第一次出现的位置 |
| `strpbrk(s1, s2)` | 在 `s1` 中查找 `s2` 中**任一字符**第一次出现的位置 |
| `strspn(s1, s2)` | 返回 `s1` 开头连续包含 `s2` 中字符的长度 |
| `strcspn(s1, s2)` | 返回 `s1` 开头连续**不**包含 `s2` 中字符的长度 |
| `strtok(s1, s2)` | 以 `s2` 中的字符为分隔符，将 `s1` 分割为记号 |

```c
// 查找子串
char *p = strstr("Hello World", "World");
if (p != NULL)
    printf("找到: %s\n", p);    // 输出 "World"

// 分割字符串
char s[] = "one,two,three";
char *tok = strtok(s, ",");
while (tok != NULL) {
    printf("%s\n", tok);
    tok = strtok(NULL, ",");   // 后续调用传 NULL
}
```

<aside>
⚠️

`strtok` 会**修改**原字符串（用 `\0` 替换分隔符），并且使用**静态内部状态**，因此：

- 不能同时对两个字符串进行分割
- 不是线程安全的
- 不能用于字符串字面量（只读）
</aside>

### 其他函数

| 函数 | 说明 |
| --- | --- |
| `strlen(s)` | 返回字符串长度（不含 `\0`） |
| `strerror(n)` | 返回错误码 `n` 对应的错误描述字符串 |

## 23.6 <stdlib.h> 中的数值转换函数

### 字符串转数值

| 函数 | 说明 |
| --- | --- |
| `atoi(s)` | 字符串 → int |
| `atol(s)` | 字符串 → long |
| `atof(s)` | 字符串 → double |

```c
int n = atoi("42");          // n = 42
double d = atof("3.14");    // d = 3.14
```

<aside>
⚠️

`ato*` 系列函数**无法检测错误**（溢出或非法输入时行为未定义）。推荐使用 `strtol`、`strtoul`、`strtod` 等替代。

</aside>

### 更安全的转换函数

| 函数 | 说明 |
| --- | --- |
| `strtol(s, &end, base)` | 字符串 → long，支持指定进制（2-36），`end` 指向未转换部分 |
| `strtoul(s, &end, base)` | 字符串 → unsigned long |
| `strtod(s, &end)` | 字符串 → double |

```c
char *end;
long val = strtol("  123abc", &end, 10);
// val = 123, end 指向 "abc"

// 检测错误
errno = 0;
long big = strtol("99999999999999999999", &end, 10);
if (errno == ERANGE)
    printf("溢出！\n");

// 指定进制
long hex = strtol("FF", NULL, 16);    // hex = 255
long bin = strtol("1010", NULL, 2);   // bin = 10
```

<aside>
📌

`strtol` 的 `base` 参数设为 **0** 时，会根据前缀自动判断进制：

- `0x` 或 `0X` 开头 → 十六进制
- `0` 开头 → 八进制
- 其他 → 十进制
</aside>

### 伪随机数生成

| 函数/宏 | 说明 |
| --- | --- |
| `rand()` | 返回 0 到 `RAND_MAX` 之间的伪随机整数 |
| `srand(seed)` | 设置随机数种子 |
| `RAND_MAX` | `rand()` 返回的最大值，至少为 32767 |

```c
#include <stdlib.h>
#include <time.h>

srand((unsigned)time(NULL));   // 用当前时间作为种子

// 生成 [0, 99] 范围的随机数
int r = rand() % 100;

// 生成 [a, b] 范围的随机数
int random_range(int a, int b) {
    return a + rand() % (b - a + 1);
}
```

## 23.7 <string.h> 中的内存操作函数

`<string.h>` 还提供了一组按**字节**操作内存的函数，参数类型为 `void *`，可用于任意类型的数据：

| 函数 | 说明 |
| --- | --- |
| `memcpy(dest, src, n)` | 从 `src` 复制 `n` 字节到 `dest`（不可重叠） |
| `memmove(dest, src, n)` | 从 `src` 复制 `n` 字节到 `dest`（可以重叠） |
| `memcmp(s1, s2, n)` | 按字节比较 `n` 个字节 |
| `memchr(s, c, n)` | 在 `s` 的前 `n` 个字节中查找字节 `c` |
| `memset(s, c, n)` | 将 `s` 的前 `n` 个字节设置为 `c` |

```c
int a[5] = {1, 2, 3, 4, 5};
int b[5];

memcpy(b, a, sizeof(a));        // 复制整个数组
memset(b, 0, sizeof(b));        // 全部清零

// 比较两个数组
if (memcmp(a, b, sizeof(a)) == 0)
    printf("数组内容相同\n");
```

<aside>
⚠️

`memcpy` 在源和目标**内存重叠**时行为未定义，重叠时必须使用 `memmove`：

```c
char s[] = "Hello World";
memmove(s, s + 6, 5);    // ✅ 安全：内存可能重叠
memcpy(s, s + 6, 5);     // ❌ 未定义行为：内存重叠
```

</aside>

## 23.8 小结

| 头文件 | 用途 | 关键内容 |
| --- | --- | --- |
| `<float.h>` | 浮点类型特性 | `DBL_MAX`、`DBL_EPSILON`、`DBL_DIG` 等 |
| `<limits.h>` | 整数类型范围 | `INT_MIN`、`INT_MAX`、`CHAR_BIT` 等 |
| `<math.h>` | 数学计算 | 三角、指数、对数、幂、取整函数 |
| `<ctype.h>` | 字符分类与转换 | `isalpha`、`isdigit`、`toupper` 等 |
| `<string.h>` | 字符串与内存操作 | `strcpy`、`strcmp`、`strstr`、`memcpy` 等 |
| `<stdlib.h>` | 数值转换与随机数 | `strtol`、`strtod`、`rand` 等 |

> 本章涵盖了 C 标准库中处理数值和字符数据的核心头文件。关键要点：用 `<limits.h>` 和 `<float.h>` 查询类型范围以编写**可移植**代码；优先使用 `strtol` / `strtod` 而非 `atoi` / `atof` 进行**安全的字符串转数值**；使用 `<ctype.h>` 函数而非手写范围判断来**分类字符**；理解 `memcpy` 与 `memmove` 在**内存重叠**时的区别。
>