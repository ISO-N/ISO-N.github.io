---
title: 第6章 可以工作的类
date: 2026-02-17 15:24:57
categories:
- [软件工程, 理论]
tags:
- 代码大全
---
## 6.1 类的基础：抽象数据类型（ADT）

- **ADT** 是指一组数据以及对这组数据所能进行的操作的集合
- 即使编程语言不直接支持 ADT，你也应该**用 ADT 的思维来编程**
- 使用 ADT 的好处：
    - **隐藏实现细节**：外部代码不需要知道数据的内部表示
    - **限制变化的影响范围**：修改数据类型时只需改动一处
    - **让接口提供更多信息**：比如用 `currentFont.SetSize(12)` 代替直接操作结构体成员
    - **更容易提高性能**：优化只在 ADT 内部进行，不影响外部
    - **让程序更具自文档化特性**：代码读起来更像是对问题域的描述
    - **不必在程序中到处传递数据**：数据和操作绑定在一起
- **把常见的底层数据类型也当作 ADT 来处理**，如把栈当作 ADT 而非简单数组
- 在非面向对象的环境中，可以用**命名约定 + 访问子程序**来模拟 ADT

## 6.2 良好的类接口

### 好的抽象

- 类的接口应该展示出**一致的抽象层次**
    - 每个类应该实现且仅实现**一个 ADT**
    - 如果发现一个类混合了多个 ADT 的功能，应拆分成多个类
- **让接口可编程，而非表达语义**
    - 接口契约应通过编译器可检查的方式表达，而不仅是靠文档中的"请不要……"
- **注意对抽象的侵蚀**：
    - 不要暴露内部实现的成员数据
    - 不要在接口中加入与抽象不一致的公共方法
- **同时考虑抽象性与内聚性**：
    - 如果一个类的方法们不在同一个抽象层次上，说明这个类需要重新设计
- **提供成对的服务**：如果提供了 `TurnOn()`，通常也需要 `TurnOff()`；如果有 `Add()`，通常也需要 `Remove()`
- **将不相关的信息转移到其他类中**，不要在一个类里塞入不属于它的功能
- **让接口尽可能地窄**，不要暴露不需要的方法（最小化可访问性）
- **不要从类外部调用某个方法的结果去调用另一个方法**——这意味着你暴露了实现链

### 良好的封装

- **尽量减少类和成员的可访问性**：默认应该是 `private`，只在必要时才放宽
- **不要公开暴露成员数据**：提供访问器方法（getter/setter）来代替直接暴露
- **不要把私有的实现细节放入类的接口中**
    - 某些语言（如 C++）要求在头文件中声明私有成员，这是语言的妥协，不是设计指导
- **不要对类的使用者做假设**：不要假设调用者会以某种特定的顺序调用方法
- **避免使用友元类（friend class）**，它破坏了封装
- **不要因为一个子程序只使用了公共方法就将它放到公共接口中**
- **优先让阅读代码方便而非编写代码方便**：代码被阅读的次数远多于编写的次数
- **警惕从语义上破坏封装**：
    - 即使通过接口访问，如果调用者需要了解内部实现才能正确使用，封装也被破坏了

## 6.3 有关设计和实现的问题

### 包含（"有一个"关系）

- **包含是面向对象编程中最简单、最重要的关系**
- 通过**成员数据**实现包含：类 A "有一个" 类 B 的实例作为成员
- **限制包含的成员数量**：当一个类包含超过约 **7 个**数据成员时，考虑是否应该拆分
- 对于"万能类"（God Class），应将其拆分为多个更小、更专注的类

### 继承（"是一个"关系）

- 继承的核心意义是表达 **"is-a"** 关系
- 使用继承时需遵循的规则：
    - **用 `public` 继承表达"是一个"关系**：每个派生类都必须能完全代替基类（里氏替换原则 LSP）
    - **要么为继承而设计并做好文档说明，要么就禁止继承**
    - **遵循里氏替换原则**：派生类必须能在任何使用基类的地方正确工作
    - **确保只继承需要继承的部分**：如果只想复用实现，用组合或私有继承
    - **不要"覆盖"一个不可覆盖的方法**（通过命名遮蔽等技巧绕过限制）
    - **把公共的接口、数据和行为尽量放在继承树的高处**
    - **对只有一个实例的类保持警惕**：可能意味着应该用对象而非类来建模
    - **对只有一个派生类的基类保持警惕**：不要为了"将来可能用到"而创建基类
    - **对于覆盖了某个方法但内部什么也不做的派生类保持警惕**：可能是继承层次设计有误
    - **避免深层次的继承树**：建议不超过 **2~3 层**，超过时优先考虑组合
    - **优先使用多态而非大量的类型检查（type checking）**
- **何时使用继承，何时使用组合？**
    - 如果多个类共享**数据**但不共享行为 → 将公共数据放入一个对象，各类**包含**该对象
    - 如果多个类共享**行为**但不共享数据 → 让它们从共同的基类**继承**或实现共同的接口
    - 如果多个类**既共享数据也共享行为** → 让它们从包含公共数据和行为的基类**继承**
    - 如果想**用基类来控制接口** → 用继承；如果想**自己控制接口** → 用包含

### 成员函数和成员数据

- **让类中方法的数量尽可能少**
- **禁止隐式地生成你不需要的成员函数和运算符**
- **减少类所调用的不同方法的数量**：一个类调用的其他类的方法越多，出错和修改的风险就越高
- **尽量减少类之间的间接调用**（得墨忒耳法则 / Law of Demeter）：
    - `A.GetB().GetC().DoSomething()` 这样的链式调用说明耦合过紧

### 构造函数

- **在所有构造函数中初始化所有成员数据**：避免部分初始化的对象
- **优先在构造函数中使用深拷贝（deep copy）**，除非有理由使用浅拷贝
- **优先使用单例模式（Singleton）来强制执行单一实例**，而不是用全局数据

## 6.4 创建类的理由

以下都是**创建新类的正当理由**：

- **对现实世界中的对象建模**
- **对抽象的对象建模**
- **降低复杂度**：将复杂的逻辑封装在类内部
- **隔离复杂度**：让复杂度不会扩散到系统其他部分
- **隐藏实现细节**
- **限制变化的影响范围**
- **隐藏全局数据**：用类包装全局数据，通过方法访问
- **让参数传递更流畅**：如果多个方法总是传递同一组参数，将这些参数打包成一个类
- **建立中心控制点**：在一个地方控制某个概念（如数据库访问、设备 I/O）
- **让代码更容易重用**
- **为程序族做计划**：预见未来的变化，用类来隔离
- **完成一个特定的重构**

### 应该避免的类

- **万能类（God Class）**：一个类做了太多事情
- **无关紧要的类**：如果一个类只包含数据没有行为，考虑它是否真的需要是一个类
- **以动词命名的类**：一个类只有行为没有数据，通常意味着它应该是另一个类的方法

## 6.5 与语言相关的问题

- 不同语言对类的支持差异较大
    - 有的语言支持**多重继承**（如 C++），有的通过**接口**来模拟（如 Java）
    - 有的语言支持**运算符重载**，有的不支持
    - 不同语言对**构造函数/析构函数**的行为不同
- 核心建议：**不管语言支持多少特性，始终围绕良好的抽象和封装来设计类**

## 6.6 超越类：包

- 类是组织代码的基本单位，**包（Package）** 是更高一级的组织方式
- 即使语言不直接支持包（如 C++ 没有内建 package），也可以通过**命名约定和编程标准**来模拟包级别的封装
- 包级别需要关注的设计要点与类级别类似：
    - 包内的类之间应保持**高内聚**
    - 包之间应保持**低耦合**

---

<aside>
📌

**核心要点**：好的类建立在好的抽象之上。一个类应该只实现一个 ADT，拥有一致的接口抽象层次和严密的封装。优先使用包含（组合）而非继承，继承层次不宜过深。时刻以"降低复杂度"为目标来决定何时创建类、如何设计类。

</aside>

## 核对表：类的质量

### 抽象数据类型

- [ ]  你是否把程序中的类都看做是抽象数据类型了？是否从这个角度评估它们的接口了？

### 抽象

- [ ]  类是否有一个中心目的？
- [ ]  类的命名是否恰当？其名字是否表达了其中心目的？
- [ ]  类的接口是否展现了一致的抽象？
- [ ]  类的接口是否能让人清楚明白地知道该如何用它？
- [ ]  类的接口是否足够抽象，使你能够不必顾虑它是如何实现其服务的？你能把类看做黑盒子吗？
- [ ]  类提供的服务是否足够完整，能让其他类无须动用其内部数据？
- [ ]  是否已从类中除去无关信息？
- [ ]  是否考虑过把类进一步分解为组件类？是否已尽可能将其分解？
- [ ]  在修改类时是否维持了其接口的完整性？

### 封装

- [ ]  是否把类的成员的可访问性降到最小？
- [ ]  是否避免暴露类中的数据成员？
- [ ]  在编程语言所许可的范围内，类是否尽可能地对其他的类隐藏了自己的实现细节？
- [ ]  类是否避免对其使用者，包括其派生类会如何使用它做了假设？
- [ ]  类是否不依赖于其他类？它是松散耦合的吗？

### 继承

- [ ]  继承是否只用来建立“是一个/is a”的关系？也就是说，派生类是否遵循了 LSP（Liskov 替换原则）？
- [ ]  类的文档中是否记述了其继承策略？
- [ ]  派生类是否避免了“覆盖”不可覆盖的方法？
- [ ]  是否把公用的接口、数据和行为都放到尽可能高的继承层次中去了？
- [ ]  继承层次是否很浅？
- [ ]  基类中所有的数据成员是否都被定义为 private 而非 protected 的了？

### 跟实现相关的其他问题

- [ ]  类中是否只有大约七个或更少的数据成员？
- [ ]  是否把类直接或间接调用其他类的子程序的数量减到最少了？
- [ ]  类是否只在绝对必要时才与其他类相互协作？
- [ ]  是否在构造函数中初始化了所有的数据成员？
- [ ]  除非拥有经过测量的、创建浅层复本的理由，类是否都被设计为当作深层复本使用？

### 与语言相关的问题

- [ ]  你是否研究过所用编程语言里和类相关的各种特有问题？