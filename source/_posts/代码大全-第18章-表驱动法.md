---
title: 第18章 表驱动法
date: 2026-02-17 15:25:06
categories:
- [软件工程, 理论]
tags:
- 代码大全
---
## 核心思想

表驱动法是一种编程模式——从表里查找信息，而不用逻辑语句（`if/else` 或 `switch/case`）来获取。凡是能用逻辑语句来选择的事物，都可以用查表来替代。在简单情况下，逻辑语句更直观；但随着逻辑链越来越复杂，查表法的优势就愈发明显。

> 表驱动法的关键在于：**把复杂的逻辑判断转化为表的查询操作**，使代码更简洁、更易维护。
> 

---

## 使用表驱动法的两个问题

在使用表驱动法时，需要解决两个核心问题：

1. **怎样从表中查询条目？** —— 即访问表的方式
2. **应该在表里存什么？** —— 存数据值，还是存动作（如函数引用）

---

## 三种访问表的方式

### 1. 直接访问（Direct Access）

最简单的查表方式，用数据直接作为表的索引（下标）来查询结果。

**典型场景：**

- 根据月份（1~12）查询每月天数
- 根据字符查 ASCII 属性

**关键技巧——索引转换：**

当数据不能直接作为下标时，需要做简单的数学变换。例如：

- 把年龄范围映射为索引
- 把日期转化为"一年中的第几天"

<aside>
💡

直接访问的表本质上是一个数组，用键直接定位到值，时间复杂度为 **O(1)**。

</aside>

**示例：根据月份查天数**

```
daysPerMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
days = daysPerMonth[month - 1]
```

---

### 2. 索引访问（Indexed Access）

先用原始数据在**索引表**中查到一个中间键，再用这个键去访问**主查询表**。

**适用场景：**

- 原始数据的范围很大、不规律，无法直接当下标
- 需要节省主表的空间

**优点：**

- 索引表只存整数索引，占用空间小
- 主表可以复用；更改映射关系只需改索引表，维护方便

**示例：**

```
// 索引表：把不规则的 "员工编号" 映射为连续的索引
employeeIndex = { 1001: 0, 1042: 1, 1123: 2, ... }

// 主表：存放真正的数据
employeeData = [ {...}, {...}, {...}, ... ]

data = employeeData[ employeeIndex[employeeId] ]
```

---

### 3. 阶梯访问（Stair-Step Access）

表中的记录对应的是**数据的区间范围**，而不是单个值。通过逐级比较确定数据落在哪个区间，从而返回对应结果。

**适用场景：**

- 数据是连续的区间（如成绩等级：A/B/C/D）
- 区间边界不规则，无法简单映射为数组下标

**注意事项：**

- 确保端点正确处理（`<` 与 `<=` 的区别）
- 考虑用**二分查找**替代顺序查找来提升效率
- 把区间上限（或下限）存入表中，而不是硬编码到 `if` 语句里

**示例：成绩等级划分**

```
rangeLimit = [50.0, 65.0, 75.0, 90.0, 100.0]
grade      = ["F",  "D",  "C",  "B",  "A" ]

// 逐级比较
for i in range(len(rangeLimit)):
    if score < rangeLimit[i]:
        return grade[i]
```

---

## 表里存什么？

表的条目既可以是**数据**，也可以是**动作**：

| 存储内容 | 说明 | 示例 |
| --- | --- | --- |
| **数据值** | 直接存储结果 | 税率表、天数表 |
| **函数引用** | 存储指向函数/方法的指针或引用，根据查表结果调用不同的函数 | 状态机的动作表、命令分发表 |
| **对象** | 存储对象实例，利用多态来执行不同行为 | 策略模式 |

---

## 表驱动法 vs 逻辑判断

| 对比维度 | 逻辑判断（if/else, switch） | 表驱动法 |
| --- | --- | --- |
| **可读性** | 分支少时直观 | 分支多时更清晰 |
| **可维护性** | 新增/修改需改代码逻辑 | 只需改表数据 |
| **灵活性** | 逻辑写死在代码中 | 表可以外部化（配置文件、数据库） |
| **性能** | 可能更快（编译器优化） | 查表通常 O(1) 或 O(log n) |
| **复杂度** | 随分支增多而急剧膨胀 | 复杂度集中在表的构建上 |

---

## 实践要点

- [ ]  **把复杂的多分支逻辑重构为表驱动**——当 `if/else` 或 `switch` 超过 5~10 个分支时，就应该考虑
- [ ]  **把表数据与程序逻辑分离**——表可以放在常量、配置文件或数据库中，方便修改
- [ ]  **注意边界条件**——尤其是阶梯访问法，端点处理容易出错
- [ ]  **为表添加查询失败的默认处理**——防止非法输入导致越界或空值
- [ ]  **优先选择直接访问**——它最简单、最快；只有在无法直接访问时才用索引或阶梯方式

---

## 小结

> 表驱动法的精髓：**用数据的复杂性取代代码的复杂性。** 当逻辑变化频繁或分支过多时，改数据永远比改代码更安全、更灵活。
>