---
title: 第11章 指针
date: 2026-02-17 02:20:25
categories:
- [编程技术, C]
tags:
- C语言程序设计-现代方法
---
## 11.1 指针变量

### 什么是指针

指针是一个**存储地址**的变量。普通变量直接存放数据，而指针变量存放的是**另一个变量的地址**。

```c
int i = 10;
int *p = &i;   // p 存放 i 的地址
```

通过指针可以**间接访问**它所指向的变量，这是 C 语言最强大也最危险的特性之一。

### 指针变量的声明

声明指针变量时，使用 `*` 表示该变量是指针类型：

```c
int *p;         // p 是指向 int 的指针
double *q;      // q 是指向 double 的指针
char *s;        // s 是指向 char 的指针
```

- `*` 是声明的一部分，不是运算符
- 每个指针变量前都需要 `*`：

```c
int *p, *q;     // p 和 q 都是指针
int *p, q;      // p 是指针，q 是普通 int（常见错误）
```

<aside>
⚠️

声明多个指针时，**每个变量名前都要加** `*`。`int *p, q;` 中 `q` **不是**指针！

</aside>

## 11.2 取地址运算符与间接寻址运算符

### 取地址运算符 &

`&` 运算符用于获取变量的**地址**：

```c
int i = 10;
int *p = &i;    // p 指向 i
```

- `&` 只能用于**左值**（lvalue），即有确定存储位置的对象
- 不能对常量、表达式或 `register` 变量取地址

### 间接寻址运算符 *

`*` 运算符（也叫**解引用**运算符）用于访问指针所指向的对象：

```c
int i = 10;
int *p = &i;

printf("%d\n", *p);   // 输出 10（读取 p 指向的值）
*p = 20;               // 修改 p 指向的值，i 变为 20
```

<aside>
📌

`&` 和 `*` 是**互逆运算**：

- `*(&i)` 等价于 `i`
- `&(*p)` 等价于 `p`
</aside>

### 通过指针修改变量

指针最直接的用途是**间接修改**变量的值：

```c
int i = 10;
int *p = &i;
*p = 20;         // i 的值变为 20
printf("%d\n", i); // 输出 20
```

<aside>
⚠️

**绝不要对未初始化的指针**使用 `*` 运算符！未初始化的指针指向随机地址，解引用会导致**未定义行为**，可能导致程序崩溃或数据损坏。

```c
int *p;       // 未初始化，指向未知地址
*p = 10;      // ❌ 未定义行为！
```

</aside>

## 11.3 指针赋值

### 指针之间的赋值

可以将一个指针的值赋给**同类型**的另一个指针：

```c
int i = 10;
int *p = &i;
int *q = p;     // q 也指向 i

*q = 20;        // i 变为 20
printf("%d\n", *p);  // 输出 20（p 和 q 指向同一个变量）
```

### 指针赋值图示

```
赋值前：       赋值后（q = p）：
p → [i: 10]    p → [i: 10] ← q
q → ???
```

- 赋值后 `p` 和 `q` 指向**同一个对象**，通过任一指针修改都会影响该对象
- 这**不是**复制数据，而是共享地址

## 11.4 指针作为参数

### 值传递的局限

C 语言函数参数采用**值传递**，函数内无法修改调用者的变量：

```c
void swap(int a, int b)   // ❌ 无效的交换
{
    int temp = a;
    a = b;
    b = temp;
    // a, b 是局部副本，修改不影响实参
}
```

### 用指针实现"引用传递"

传递变量的**地址**，函数通过指针间接修改原变量：

```c
void swap(int *a, int *b)   // ✅ 正确的交换
{
    int temp = *a;
    *a = *b;
    *b = temp;
}

// 调用时传地址
int x = 1, y = 2;
swap(&x, &y);   // x = 2, y = 1
```

<aside>
📌

传递指针本质上仍是**值传递**——传递的是地址的副本。但因为函数拿到了地址，就可以通过 `*` 修改原变量。这是 C 语言中模拟"引用传递"的标准做法。

</aside>

### 用指针从函数"返回"多个值

C 函数只能 `return` 一个值。要"返回"多个结果，可以用指针参数：

```c
void find_min_max(int a[], int n, int *min, int *max)
{
    *min = *max = a[0];
    for (int i = 1; i < n; i++) {
        if (a[i] < *min) *min = a[i];
        if (a[i] > *max) *max = a[i];
    }
}

// 调用
int lo, hi;
find_min_max(arr, n, &lo, &hi);
// lo 和 hi 分别得到最小值和最大值
```

### scanf 就是典型例子

`scanf` 之所以要求传 `&` 取地址，就是因为它需要通过指针将读到的值写入变量：

```c
int i;
scanf("%d", &i);   // 传递 i 的地址，scanf 通过指针写入值
```

<aside>
💡

如果忘记写 `&`，`scanf` 会把变量的**值**当作**地址**使用，导致未定义行为。这是初学者最常见的错误之一。

</aside>

## 11.5 指针作为返回值

函数可以返回指针：

```c
int *max(int *a, int *b)
{
    if (*a > *b)
        return a;
    else
        return b;
}

// 调用
int x = 10, y = 20;
int *p = max(&x, &y);
printf("%d\n", *p);     // 输出 20
```

<aside>
⚠️

**永远不要返回指向局部变量的指针！** 局部变量在函数返回后被销毁，指针将成为**悬空指针**（dangling pointer），使用它会导致未定义行为：

```c
int *bad_func(void)
{
    int local = 42;
    return &local;    // ❌ local 在函数返回后不再存在
}
```

</aside>

可以安全返回的指针包括：

- 指向**静态变量**（`static`）的指针
- 指向**传入参数**所指对象的指针
- 指向**动态分配内存**的指针（`malloc`，详见第 17 章）

## 11.6 小结

| 概念 | 语法 | 含义 |
| --- | --- | --- |
| 声明指针 | `int *p;` | p 是指向 int 的指针 |
| 取地址 | `&i` | 获取变量 i 的地址 |
| 解引用 | `*p` | 访问 p 指向的对象 |
| 指针赋值 | `q = p` | q 和 p 指向同一对象 |
| 指针参数 | `void f(int *p)` | 通过指针间接修改实参 |
| 指针返回值 | `int *f(…)` | 返回指向某对象的指针 |

> 指针是 C 语言的核心特性。关键要点：理解 `&`（取地址）和 `*`（解引用）的**互逆关系**、利用指针参数实现**间接修改**和**多返回值**、**不要使用未初始化的指针**、**不要返回指向局部变量的指针**。
>