---
title: 第19章 程序设计
date: 2026-02-17 02:20:30
categories:
- [编程技术, C]
tags:
- C语言程序设计-现代方法
---
## 19.1 模块

### 什么是模块

大型程序需要被分解为**模块**（module）——一组相关的服务（函数、类型定义、变量等）的集合。每个模块有一个**接口**（interface）来描述可用的服务，模块的**实现**（implementation）则包含接口背后的具体代码。

<aside>
📌

模块的核心思想：**将相关功能组织在一起，通过明确的接口对外提供服务，同时隐藏内部实现细节。**

</aside>

### C 语言中的模块

在 C 语言中，模块通过**一对文件**实现：

- **头文件**（`.h`）：定义模块的接口（函数原型、类型定义、宏等）
- **源文件**（`.c`）：提供模块的实现

```c
// stack.h —— 接口
#ifndef STACK_H
#define STACK_H

void push(int value);
int pop(void);
int is_empty(void);

#endif
```

```c
// stack.c —— 实现
#include "stack.h"

#define STACK_SIZE 100

static int contents[STACK_SIZE];
static int top = 0;

void push(int value) { contents[top++] = value; }
int pop(void)        { return contents[--top]; }
int is_empty(void)   { return top == 0; }
```

### 模块的优点

- **抽象**：使用模块时只需了解接口，无需了解实现
- **可复用**：模块可在多个程序中使用
- **可维护**：修改实现不影响使用者，只要接口不变

## 19.2 信息隐藏

### 为什么需要信息隐藏

信息隐藏是指**将实现细节隐藏在模块内部**，不让外部代码直接访问。这是良好的程序设计中最重要的原则之一。

好处：

- **安全性**：外部代码无法破坏模块的内部状态
- **灵活性**：实现可以自由更改，不影响外部代码
- **可理解性**：使用者只需关注接口

### `static` 关键字实现信息隐藏

在 C 语言中，`static` 用于将变量和函数的**作用域限制在当前文件**内：

```c
// stack.c
static int contents[STACK_SIZE];  // 外部文件无法访问
static int top = 0;               // 外部文件无法访问

static void check_overflow(void)  // 仅模块内部使用的辅助函数
{
    if (top == STACK_SIZE) {
        printf("Stack overflow\n");
        exit(EXIT_FAILURE);
    }
}

void push(int value)   // 非 static，外部可通过接口调用
{
    check_overflow();
    contents[top++] = value;
}
```

<aside>
⚠️

如果不加 `static`，变量和函数默认具有**外部链接**（external linkage），其他文件可以通过 `extern` 声明来访问它们，这会**破坏封装性**。

</aside>

### 信息隐藏的原则

- 模块的**全局变量**应声明为 `static`
- 模块的**辅助函数**（不属于接口的函数）应声明为 `static`
- **只有接口中声明的函数**才不加 `static`

## 19.3 抽象数据类型（ADT）

### 什么是抽象数据类型

**抽象数据类型**（Abstract Data Type，ADT）是对数据类型的一种封装：

- 将**数据表示**和**操作该数据的函数**绑定在一起
- 对外**隐藏数据的具体表示方式**
- 使用者只能通过**接口函数**操作数据

<aside>
📌

ADT = **数据** + **操作** + **封装**。使用者知道能对数据做什么操作（接口），但不知道数据是怎么存储的（实现）。

</aside>

### ADT 与普通模块的区别

普通模块通常只提供"一份"服务（例如一个栈），而 ADT 允许创建**多个实例**。就像 `int` 可以创建多个 `int` 变量一样，一个栈 ADT 可以创建多个独立的栈。

### 用不完整类型实现封装

C 语言可以利用**不完整类型**（incomplete type）来隐藏数据结构的细节：

```c
// stack.h —— 接口
typedef struct stack_type *Stack;  // 不完整类型，外部不知道 struct 的内容

Stack create(void);
void destroy(Stack s);
void push(Stack s, int value);
int pop(Stack s);
int is_empty(Stack s);
```

```c
// stack.c —— 实现
#include "stack.h"
#include <stdlib.h>

struct stack_type {
    int *contents;  // 动态数组
    int top;
    int size;
};

Stack create(void)
{
    Stack s = malloc(sizeof(struct stack_type));
    s->contents = malloc(100 * sizeof(int));
    s->top = 0;
    s->size = 100;
    return s;
}

void destroy(Stack s)
{
    free(s->contents);
    free(s);
}

void push(Stack s, int value)
{
    s->contents[s->top++] = value;
}

int pop(Stack s)
{
    return s->contents[--s->top];
}

int is_empty(Stack s)
{
    return s->top == 0;
}
```

<aside>
💡

头文件中只声明了 `struct stack_type` 的**指针类型**，并没有定义结构体的内容。外部代码无法直接访问 `s->top` 或 `s->contents`，只能通过 `push`、`pop` 等函数操作栈。这就是**封装**。

</aside>

### 使用 ADT

```c
#include "stack.h"

int main(void)
{
    Stack s1 = create();   // 创建第一个栈
    Stack s2 = create();   // 创建第二个栈

    push(s1, 10);
    push(s1, 20);
    push(s2, 100);

    printf("%d\n", pop(s1));  // 20
    printf("%d\n", pop(s2));  // 100

    destroy(s1);
    destroy(s2);
    return 0;
}
```

## 19.4 栈抽象数据类型的设计考量

### 命名约定

为避免命名冲突，ADT 的函数通常加上**前缀**：

```c
Stack stack_create(void);
void stack_destroy(Stack s);
void stack_push(Stack s, int value);
int stack_pop(Stack s);
int stack_is_empty(Stack s);
```

<aside>
📌

C 语言没有命名空间机制，使用**前缀**是区分不同模块函数的标准做法。

</aside>

### 错误处理

ADT 需要考虑异常情况的处理方式：

- **栈溢出**（push 时栈已满）
- **栈下溢**（pop 时栈为空）

常见策略：

```c
// 策略 1：终止程序
void stack_push(Stack s, int value)
{
    if (s->top == s->size) {
        fprintf(stderr, "Stack overflow\n");
        exit(EXIT_FAILURE);
    }
    s->contents[s->top++] = value;
}

// 策略 2：返回错误码
bool stack_push(Stack s, int value)
{
    if (s->top == s->size)
        return false;       // 失败
    s->contents[s->top++] = value;
    return true;            // 成功
}
```

### 通用 ADT

上述栈只能存储 `int`。可以使用 `void *` 使其支持**任意类型**：

```c
// 通用栈接口
typedef struct stack_type *Stack;

Stack stack_create(void);
void stack_destroy(Stack s);
void stack_push(Stack s, void *value);
void *stack_pop(Stack s);
int stack_is_empty(Stack s);
```

```c
// 使用通用栈存储不同类型
Stack s = stack_create();

int *ip = malloc(sizeof(int));
*ip = 42;
stack_push(s, ip);            // 存入 int 指针

char *str = "hello";
stack_push(s, str);           // 存入字符串指针

char *s1 = stack_pop(s);     // 取出时需要自行转换类型
int *s2 = stack_pop(s);
```

<aside>
⚠️

使用 `void *` 的通用 ADT 会**丧失类型安全性**——编译器无法检查存入和取出的类型是否一致，程序员必须自己保证类型正确。

</aside>

## 19.5 ADT 的设计问题

### 单实例 vs 多实例

| 方式 | 特点 | 适用场景 |
| --- | --- | --- |
| **单实例模块** | 用 `static` 全局变量保存状态，函数无需传入实例参数 | 程序中只需一个该类型的对象 |
| **多实例 ADT** | 用不完整类型 + `malloc`，每个函数需传入实例指针 | 需要同时存在多个独立实例 |

### 头文件的最佳实践

- 使用**头文件保护符**（include guard）防止重复包含：

```c
#ifndef STACK_H
#define STACK_H

// 接口内容

#endif
```

- 头文件中**只放声明**，不放定义（避免多重定义错误）
- 头文件中应包含：函数原型、类型定义（`typedef`）、宏定义

### 模块之间的依赖关系

设计模块时应尽量减少模块间的耦合：

- 每个模块应该**只依赖必要的其他模块**
- 避免**循环依赖**（A 依赖 B，B 又依赖 A）
- 使用**分层设计**：高层模块调用低层模块，反过来不行

## 19.6 小结

| 概念 | 含义 | C 语言实现方式 |
| --- | --- | --- |
| 模块 | 一组相关服务的集合 | `.h` 头文件（接口）+ `.c` 源文件（实现） |
| 信息隐藏 | 隐藏内部实现细节 | `static` 变量和函数 |
| 抽象数据类型 | 数据 + 操作 + 封装 | 不完整类型 + 指针 |
| 封装 | 外部无法直接访问内部数据 | `typedef struct xxx *Type;` |
| 多实例 | 可创建多个独立的数据对象 | `malloc`  • 函数传入实例指针 |
| 通用 ADT | 支持任意数据类型的 ADT | `void *` 指针 |

> 程序设计的核心理念：**模块化** + **信息隐藏** + **抽象数据类型**。用头文件定义清晰的接口，用 `static` 隐藏实现细节，用不完整类型实现封装。好的设计让每个模块可以**独立开发、测试和修改**，而不影响其他部分。
>