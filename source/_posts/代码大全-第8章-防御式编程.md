---
title: 第8章 防御式编程
date: 2026-02-17 15:24:58
categories:
- [软件工程, 理论]
tags:
- 代码大全
---
防御式编程的核心思想：**保护程序免受无效输入的破坏**，就像防御式驾驶一样——你永远不能确定其他人会怎么做，所以要主动保护自己。

---

## 8.1 保护程序免受非法输入数据的破坏

处理来自外部的垃圾输入，通常有三种方式：

- **检查所有来源的外部数据**：文件、用户输入、网络数据、命令行参数等，都不可信
- **检查子程序所有输入参数的值**：来自其他子程序的数据同样不能盲目信任
- **决定如何处理错误的输入数据**：一旦检测到非法输入，需要有明确的处理策略

## 8.2 断言（Assertions）

断言是在开发和维护阶段用来检查"**绝不应该发生**"的条件的代码。

- 断言用于检查**前条件**和**后条件**
- 断言只在开发阶段生效，在生产代码中通常被编译器移除
- 对于预期中可能发生的错误，**不要用断言**，应该用错误处理代码

### 使用断言的指导建议

- 用错误处理代码来处理**预期会发生**的错误；用断言来处理**绝不应该发生**的错误
- 避免把需要执行的代码放到断言中（如 `assert(doSomething())`）
- 用断言来注解并验证**前条件**和**后条件**
- 对于高健壮性的代码，先用断言再处理错误

## 8.3 错误处理技术

当断言不够用时（尤其是在生产环境中），需要使用错误处理技术：

- **返回中立值**：返回一个无害的值（如 0、空字符串）
- **换用下一个正确的数据**：适用于流式数据处理
- **返回与前次相同的值**：如温度传感器读数异常时返回上一次读数
- **换用最接近的合法值**：例如将超出范围的值限制在最大或最小值
- **把警告信息记录到日志文件中**：继续运行但留下记录
- **返回一个错误码**：让调用方决定如何处理
- **调用错误处理子程序或对象**：集中处理错误逻辑
- **显示出错消息**：直接通知用户
- **用最妥当的方式在局部处理错误**：灵活应对
- **关闭程序**：对于安全关键系统，宁可关闭也不能产生错误结果

### 健壮性 vs 正确性

- **正确性**：永远不返回不准确的结果，宁可不返回也不能返回错误值
- **健壮性**：尽可能持续运行，即使产生不精确的结果

> 安全关键系统倾向于**正确性**，消费类软件倾向于**健壮性**。你要根据项目需求选择合适的策略。
> 

## 8.4 异常（Exceptions）

异常是一种把代码中的错误或异常事件传递给调用方的手段。

### 使用异常的建议

- 用异常通知程序的其他部分，发生了**不可忽略的错误**
- **只在真正例外的情况下**才抛出异常，不要用异常来控制正常的程序流程
- 不能用异常来推卸责任——如果错误可以在局部处理，就在局部处理
- 避免在构造函数和析构函数中抛出异常（除非在同一位置捕获）
- 在恰当的抽象层次抛出异常，例如不要在高层业务方法中抛出底层 `IOException`
- 在异常消息中包含**引发异常的全部信息**
- 避免使用空的 `catch` 块——这相当于吞掉了错误
- 了解所用函数库会抛出的异常
- 考虑创建一个集中的**异常报告机制**

## 8.5 隔离程序以免遭受由错误造成的损害

### 隔栏（Barricades）策略

- 将程序划分为**"安全区"**和**"不安全区"**
- **隔栏外部**：对数据做充分的合法性验证（错误处理）
- **隔栏内部**：数据已经被清洗过，使用断言即可
- 类的公共接口方法承担**验证数据**的职责，私有方法可以假设数据是干净的

> 隔栏的思路类似于手术室的消毒：在入口处做好彻底清洁，内部则可以假定环境是无菌的。
> 

## 8.6 辅助调试的代码

在开发阶段，可以大量使用辅助调试代码，在发布时移除或关闭：

- **不要自动把生产版的限制强加于开发版**：开发时多分配内存、多做检查是值得的
- **尽早引入辅助调试的代码**
- 使用**进攻式编程**：在开发阶段让问题尽可能显眼
    - 确保断言能终止程序
    - 用垃圾值填充分配到的内存
    - 用垃圾值填充已释放的内存
    - 在 `switch-case` 的 `default` 中使用 `abort()`
- 计划好**移除调试辅助代码**的方式：
    - 使用版本控制工具和构建工具
    - 使用内置的预处理器
    - 编写自己的预处理器
    - 使用调试存根（stubs）

## 8.7 确定在生产代码中该保留多少防御式代码

- **保留检查重要错误的代码**
- **去掉检查细微错误的代码**
- **去掉可以导致程序硬性崩溃的代码**（如 `abort()`）
- **保留能够让程序优雅崩溃的代码**（如日志记录 + 安全退出）
- **为技术支持人员记录错误信息**
- 确保留在代码中的错误消息是**友好的**

## 8.8 对防御式编程采取防御的姿态

<aside>
⚠️

**过多的防御式编程也会带来问题**：代码变得臃肿、运行变慢、增加了复杂度本身就会引入新的错误。要有策略地使用防御式编程，而不是无脑添加。

</aside>

---

## 本章核心检查清单

- [ ]  子程序是否保护自己免受非法输入数据的损害？
- [ ]  是否使用了断言来标记"不可能发生"的情况？
- [ ]  断言是否只用于"不应发生"的条件而非预期的错误？
- [ ]  架构或高层设计是否规定了一组特定的错误处理技术？
- [ ]  架构或高层设计是否规定了错误处理是倾向健壮性还是正确性？
- [ ]  是否建立了隔栏来限制错误造成的损害？
- [ ]  代码中是否使用了辅助调试手段？
- [ ]  辅助调试的代码是否可以方便地移除？
- [ ]  防御式编程引入的代码量是否合理？是否反而引入了新的复杂度？

---

## 要点总结

> **防御式编程**是一种"以最坏的情况为假设"的编程方式。它能显著提高代码质量，但必须适度使用。关键在于：在**开发时**激进地发现问题，在**生产时**优雅地处理问题。
>