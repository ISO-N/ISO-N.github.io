---
title: 第24章 重构
date: 2026-02-17 15:25:11
categories:
- [软件工程, 理论]
tags:
- 代码大全
---
重构（Refactoring）是在**不改变软件外部行为**的前提下，改善其内部结构的过程。重构是软件演化的核心手段——代码不是写完就定型的，它需要像文章一样反复修改、润色，才能达到高质量。

---

## 24.1 软件演化的类型

- 软件的变化是不可避免的，但变化的**性质**决定了代码质量的走向
- **两种演化方向**：
    - ✅ **改善型演化**：每次修改都让代码变得更清晰、更易维护
    - ❌ **恶化型演化**：修改只为"让它能跑"，不关心结构，代码逐渐腐烂
- 关键理念：**把每次修改都当作改善代码的机会**，而不是仅仅完成功能需求

<aside>
💡

**代码演化的基本定律：** 如果你每次修改代码时都让它变得比之前好一点，代码质量就会持续提升；反之，如果只关注功能而忽视结构，代码就会逐步走向混乱。

</aside>

## 24.2 重构简介

### 什么是重构

- 重构是对代码内部结构的**等价变换**——改变代码的组织方式，但不改变其行为
- 重构不是"重写"或"大规模推翻"，而是一系列**小的、可控的改动**
- 每次重构后，代码仍然能通过所有已有的测试

### 为什么要重构

- **代码重复**（DRY 原则被违反）
- **子程序过长**，职责不清
- **循环过长或嵌套过深**
- **类的内聚性差**，一个类承担了太多不相关的职责
- **类的接口未提供一致的抽象层级**
- **参数列表过长**
- **类之间的修改总是联动的**（高耦合）
- **需要并行修改多个类的继承体系**
- **需要同时修改多个 case 语句**
- **相关的数据项总是成组出现却没有被组织成类**
- **某个子程序更多地使用了其他类的特性而非自身所在类的特性**（Feature Envy）
- **过度使用基本数据类型**而非封装为有意义的类
- **某个类做的事太少**，没有存在的价值
- **沿继承链传递的"流浪数据"**
- **注释被用来解释难懂的代码**而不是提供额外信息
- **使用了全局变量**
- **在子程序调用前后有大量设置/收尾代码**（Setup / Takedown code）
- **程序中存在将来可能用到的代码**（YAGNI 违反）

## 24.3 特定的重构

### 数据级的重构

- 用**具名常量替代魔法数字**
- 用更**清晰、信息量更大的名字**重命名变量
- 将**表达式内联化**或提取为中间变量，使逻辑更易读
- 用**函数调用替代表达式**，消除重复计算
- 引入**中间变量**来分解复杂的布尔表达式
- 用**多个单一用途的变量替代一个多用途变量**
- 使用**局部变量**代替参数进行内部操作，保持参数值不变
- 将**基本数据类型封装为类**（如将 `money` 从 `float` 封装为 `Money` 类）
- 将**类型码（type code）转换为类或枚举**
- 将**数组转换为对象**（当数组的不同元素代表不同含义时）
- 封装集合（**返回集合的只读视图**而非直接暴露内部集合）

### 语句级的重构

- **分解布尔表达式**：引入有意义的中间变量来阐述意图
- 将**复杂的布尔表达式提取为函数**，用函数名表达判断条件的含义
- **合并条件语句中的重复代码片段**
- 使用 `break` 或 `return` 代替**循环控制变量**，简化循环逻辑
- 在嵌套的 `if-else` 中**提前返回**，减少嵌套层级
- 用**多态**替代条件判断（尤其是重复出现的 `switch/case`）
- 创建和使用**空对象（Null Object）**来替代反复出现的 `null` 检查

### 子程序级的重构

- **提取子程序（Extract Method）**：将一段代码从现有子程序中提取为独立子程序
- **内联子程序（Inline Method）**：将过于简单的子程序内联到调用处
- 将**冗长的子程序转化为类**
- 用**简单的算法替代复杂的算法**
- **添加或移除参数**
- 将**查询操作与修改操作分离**（Command-Query Separation）
- 通过**参数化**来合并相似的子程序
- 将**行为因参数而异的子程序拆分为独立的子程序**
- **传递整个对象而非多个字段**
- **传递具体字段而非整个对象**（当只需少量字段时，降低耦合）
- **封装向下转型（Downcast）操作**

### 类实现级的重构

- 将**值对象改为引用对象**，或反之
- 用**数据初始化替代虚函数**
- 改变**成员函数或数据的位置**（向上/向下移动到基类或子类）
- 将**特化代码提取为子类**
- 将**相似代码合并到父类中**

### 类接口级的重构

- 将**成员函数移到另一个类**
- 将**一个类拆分为两个**
- **删除没有存在价值的类**
- **隐藏委托关系**（引入中间方法，避免链式调用 `a.getB().getC()`）
- **移除中间人**（如果委托层过多导致代码更复杂）
- 用**继承替换委托**，或用**委托替换继承**
- 引入**外部方法（Extension Method）**来为不可修改的类添加功能
- 引入**扩展类**来集中管理对不可修改类的多个扩展
- **封装暴露的成员变量**（提供 getter/setter）
- 对于**不可修改的成员，移除 setter**
- **隐藏不应被外部使用的成员函数**
- **封装不使用的成员函数**（接口隔离）
- 如果**父类和子类的实现非常接近，将它们合并**

### 系统级的重构

- 为**不可控的数据创建明确的数据源**
- 将**单向的类关联改为双向**，或反之
- 用 **Factory Method** 替代简单的构造函数
- 用**异常替代错误码**，或反之（视项目约定）

## 24.4 安全地重构

重构虽然不改变行为，但操作不当仍可能引入缺陷。以下是降低风险的关键实践：

- **每次保存代码的初始状态**：用版本控制确保可以随时回退
- **重构的步子要小**：每次只做一个小的变换，不要一次大改
- **一次只做一项重构**：不要同时进行多项结构调整
- **列出你打算采取的步骤**：在动手之前，先明确计划
- **设置一个"停车场"**：把重构过程中发现的其他问题记录下来，以后再处理
- **多使用检查点**：每完成一步就运行测试，确认没有破坏任何东西
- **利用编译器的警告**：编译器能帮你捕获一些重构引入的错误
- **重新测试**：重构后必须运行所有相关测试
- **添加测试用例**：如果现有测试不足以覆盖重构影响的代码路径，先补充测试
- **审查修改**：小的重构可以自查，大的重构应请人做代码审查

<aside>
⚠️

**重构不是"先搞坏再修好"。** 如果你发现一次重构需要同时改动大量代码才能通过编译，说明你的步子迈得太大了——退回去，把它拆成更小的步骤。

</aside>

## 24.5 重构策略

### 何时重构

- **添加子程序时**：检查相关代码是否可以改善
- **添加类时**：审视现有类是否需要拆分或重组
- **修复缺陷时**：缺陷往往暴露设计问题，趁机改善
- **代码审查时**：审查发现的问题是重构的绝佳时机
- **当你对代码感到不舒服时**：如果代码让你觉得"别扭"，相信你的直觉

### 不适合重构的情况

- **接口混乱到无法修补**：这时候需要的是**重写**而不是重构
- **代码是正确的但设计完全错误**：重构适合改善，不适合推倒重来
- **临近项目交付期限**：重构会引入短期风险，应在时间充裕时进行

### 重构的实用建议

- **维护一份"应该重构"的清单**：发现问题时记录下来，合适的时候集中处理
- 将重构视为**日常编码的一部分**，而非独立的大型任务
- **频繁做小重构**远好于偶尔做大规模重构
- 对**高风险模块**额外投入重构精力

---

## ✅ 本章核心检查清单

- [ ]  每次修改代码时是否让代码变得更好？
- [ ]  是否识别了代码中的"坏味道"（重复、过长的子程序、深层嵌套等）？
- [ ]  重构时是否保持了小步前进，每步之后都验证？
- [ ]  是否在重构前保存了代码的初始状态（版本控制）？
- [ ]  是否为重构影响的代码准备了充分的测试？
- [ ]  是否避免了同时进行重构和功能开发？
- [ ]  重构后是否重新运行了所有测试？
- [ ]  大规模重构是否经过了代码审查？

---

## 要点总结

> **重构是软件构建中不可或缺的一环。** 代码在第一次编写时很少是最优的，正如写文章需要反复修改一样，代码也需要持续打磨。关键在于：识别代码中的"坏味道"，采用**小步、安全的等价变换**改善结构，并通过**测试和版本控制**确保每次变换都不引入新问题。将重构融入日常开发习惯，而不是等到代码"烂到不行"才动手。
>