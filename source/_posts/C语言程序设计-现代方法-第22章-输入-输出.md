---
title: 第22章 输入 输出
date: 2026-02-17 02:20:32
categories:
- [编程技术, C]
---
## 22.1 流

- C 语言的输入/输出通过**流**（stream）来完成，流是对各种输入/输出设备（键盘、屏幕、磁盘文件等）的统一抽象
- 访问流不需要了解底层设备的细节，同一套函数可以操作不同设备

### 文件指针

- 流通过 `FILE *` 类型的**文件指针**来访问
- `FILE` 是在 `<stdio.h>` 中定义的类型（通常是结构体），存储了流的状态信息
- 程序员不需要了解 `FILE` 的内部细节，只需使用指向它的指针

### 标准流和重定向

程序开始运行时，默认打开三个标准流：

| **文件指针** | **流** | **默认含义** |
| --- | --- | --- |
| `stdin` | 标准输入 | 键盘 |
| `stdout` | 标准输出 | 屏幕 |
| `stderr` | 标准错误 | 屏幕 |
- 通过**输入/输出重定向**可以改变标准流的来源和去向：

```
./program <input.txt >output.txt  # stdin 来自文件，stdout 写入文件
./program >>log.txt               # 追加模式重定向
```

- `stderr` 不受 `>` 重定向的影响，错误信息仍然显示在屏幕上

### 文本文件与二进制文件

- **文本流**（text stream）：由一系列**行**组成，每行以换行符结尾。不同平台行尾表示不同（Windows: `\r\n`，Unix/Mac: `\n`），C 标准库会自动转换
- **二进制流**（binary stream）：字节的直接序列，不做任何转换

<aside>
💡

在 Unix/Linux 系统上，文本模式和二进制模式没有区别。但在 Windows 上，以文本模式打开文件时 `\r\n` 会被转换为 `\n`，以二进制模式打开则不会。

</aside>

---

## 22.2 文件操作

### 打开文件

```c
FILE *fopen(const char *filename, const char *mode);
```

- 成功返回文件指针，失败返回 `NULL`
- **必须检查返回值**：

```c
FILE *fp = fopen("data.txt", "r");
if (fp == NULL) {
    printf("Can't open data.txt\n");
    exit(EXIT_FAILURE);
}
```

### 模式字符串

| **模式** | **含义** | **文件不存在** | **文件已存在** |
| --- | --- | --- | --- |
| `"r"` | 只读 | 失败 | 从头读取 |
| `"w"` | 只写 | 创建新文件 | **清空内容** |
| `"a"` | 追加 | 创建新文件 | 在末尾写入 |
| `"r+"` | 读写 | 失败 | 从头读写 |
| `"w+"` | 读写 | 创建新文件 | **清空内容** |
| `"a+"` | 读 + 追加 | 创建新文件 | 读任意位置，写在末尾 |
- 在模式字符串中加入 `b` 表示二进制模式：`"rb"`、`"wb"`、`"ab"` 等

<aside>
⚠️

`"w"` 模式会**立即清空**已有文件的全部内容！如果只想追加数据，务必使用 `"a"` 模式。

</aside>

### 关闭文件

```c
int fclose(FILE *fp);
```

- 成功返回 `0`，失败返回 `EOF`
- 关闭文件会**刷新缓冲区**中未写入的数据
- 程序结束时会自动关闭所有打开的文件，但最好养成显式关闭的习惯

### 附加到文件（`freopen`）

```c
FILE *freopen(const char *filename, const char *mode, FILE *stream);
```

- 关闭 `stream` 当前关联的文件，然后用指定的 `filename` 和 `mode` 重新打开
- 常用于重定向标准流：

```c
// 将 stdout 重定向到文件
freopen("output.txt", "w", stdout);
printf("This goes to file\n");  // 写入 output.txt 而非屏幕
```

### 临时文件

```c
FILE *tmpfile(void);   // 创建临时文件（"wb+"模式），程序结束时自动删除
char *tmpnam(char *s);  // 生成唯一的临时文件名
```

### 文件缓冲

- I/O 通常是**缓冲**的，数据先写入内存缓冲区，满了才写入文件
- **全缓冲**（full buffering）：缓冲区满时刷新（磁盘文件默认）
- **行缓冲**（line buffering）：遇到换行符时刷新（`stdout` 连接终端时默认）
- **无缓冲**（unbuffered）：每次操作直接执行（`stderr` 默认）

```c
int fflush(FILE *fp);  // 手动刷新缓冲区

// 修改缓冲方式
setvbuf(fp, buf, _IOFBF, BUFSIZ);  // 全缓冲
setvbuf(fp, buf, _IOLBF, BUFSIZ);  // 行缓冲
setvbuf(fp, NULL, _IONBF, 0);      // 无缓冲
```

### 其他文件操作

```c
int remove(const char *filename);  // 删除文件
int rename(const char *old, const char *new);  // 重命名文件
```

---

## 22.3 格式化输入/输出

### `fprintf` 和 `printf`

```c
int fprintf(FILE *fp, const char *format, ...);
int printf(const char *format, ...);  // 等价于 fprintf(stdout, ...)
```

- 返回写入的字符数，出错返回负值

### 转换说明

`%` 后的格式：`%[标志][最小字段宽度][.精度][长度修饰符]转换说明符`

**常用转换说明符**：

| **说明符** | **含义** | **示例** |
| --- | --- | --- |
| `d` / `i` | 十进制整数 | `printf("%d", 42)` → `42` |
| `u` | 无符号十进制整数 | `printf("%u", 42)` → `42` |
| `o` | 八进制 | `printf("%o", 42)` → `52` |
| `x` / `X` | 十六进制 | `printf("%x", 255)` → `ff` |
| `f` | 浮点数 | `printf("%f", 3.14)` → `3.140000` |
| `e` / `E` | 科学记数法 | `printf("%e", 3.14)` → `3.140000e+00` |
| `g` / `G` | 自动选择 `f` 或 `e` | `printf("%g", 3.14)` → `3.14` |
| `c` | 字符 | `printf("%c", 'A')` → `A` |
| `s` | 字符串 | `printf("%s", "hi")` → `hi` |
| `p` | 指针 | `printf("%p", ptr)` |
| `%` | 输出 `%` 本身 | `printf("%%")` → `%` |

**标志**：

- `-`：左对齐
- `+`：正数前显示 `+`
- 空格：正数前显示空格
- `0`：用 `0` 填充
- `#`：备用格式（如 `%#x` → `0xff`）

### `fscanf` 和 `scanf`

```c
int fscanf(FILE *fp, const char *format, ...);
int scanf(const char *format, ...);  // 等价于 fscanf(stdin, ...)
```

- 返回成功匹配并赋值的项数
- 输入结束返回 `EOF`

### `scanf` 的格式字符串规则

- **空白字符**：匹配输入中零个或多个空白字符
- **非空白普通字符**：必须精确匹配
- **转换说明**：读取并转换输入项

```c
int day, month, year;
scanf("%d/%d/%d", &month, &day, &year);  // 输入: 2/14/2026
```

- `*` 赋值屏蔽：`scanf("%*d %d", &n)` 跳过第一个整数

<aside>
⚠️

`scanf` 的 `%s` 不会读取空格，无法读取整行。读取整行应使用 `fgets`。另外，`scanf` 中的 `\n` 不代表"匹配换行符"，而是"跳过所有空白"，这是一个常见误区。

</aside>

### `sprintf` 和 `sscanf`

```c
int sprintf(char *s, const char *format, ...);   // 写入字符串
int snprintf(char *s, size_t n, const char *format, ...); // C99，更安全
int sscanf(const char *s, const char *format, ...);       // 从字符串读取
```

- `sprintf` 将格式化结果写入字符数组而非文件
- `snprintf`（C99）限制写入长度，防止缓冲区溢出
- `sscanf` 从字符串中按格式读取数据

```c
char buf[100];
sprintf(buf, "Score: %d/%d", 85, 100);  // buf = "Score: 85/100"

int a, b;
sscanf("85 100", "%d %d", &a, &b);     // a=85, b=100
```

---

## 22.4 字符输入/输出

### 输出函数

```c
int fputc(int c, FILE *fp);    // 向流写入一个字符
int putchar(int c);            // 等价于 fputc(c, stdout)
int putc(int c, FILE *fp);     // 与 fputc 类似，可能实现为宏
```

### 输入函数

```c
int fgetc(FILE *fp);           // 从流读取一个字符
int getchar(void);             // 等价于 fgetc(stdin)
int getc(FILE *fp);            // 与 fgetc 类似，可能实现为宏
```

- 这些函数返回 `int` 而非 `char`，因为到达文件末尾或出错时返回 `EOF`（通常是 `-1`）

<aside>
⚠️

读取字符时必须用 `int` 类型保存返回值，不能用 `char`。否则当 `char` 是无符号类型时，永远不会等于 `EOF`，导致无限循环。

</aside>

```c
// 正确用法
int ch;
while ((ch = getchar()) != EOF)
    putchar(ch);
```

### `ungetc` — 回退字符

```c
int ungetc(int c, FILE *fp);
```

- 将字符"放回"流中，下次读取时会先读到该字符
- 保证至少能放回**一个**字符
- 常用于"预读"场景：读一个字符判断是否需要，不需要就放回

---

## 22.5 行输入/输出

### 输出函数

```c
int fputs(const char *s, FILE *fp);  // 写入字符串，不自动加换行
int puts(const char *s);             // 写入字符串并自动加换行
```

### 输入函数

```c
char *fgets(char *s, int n, FILE *fp);
```

- 最多读取 `n - 1` 个字符，遇到换行符或 EOF 停止
- **保留换行符**（如果读到了的话）
- 在末尾添加 `\0`
- 成功返回 `s`，到达文件末尾或出错返回 `NULL`

```c
char line[100];
while (fgets(line, sizeof(line), fp) != NULL) {
    // 处理每一行
    // 注意：line 中可能包含末尾的 '\n'
}
```

<aside>
📌

`gets` 函数因无法限制输入长度（容易缓冲区溢出）已在 **C11** 中被移除。始终使用 `fgets` 代替。如需去除末尾换行符：

```c
line[strcspn(line, "\n")] = '\0';
```

</aside>

---

## 22.6 块输入/输出

`fread` 和 `fwrite` 用于一次读写**多个数据项**（如数组、结构体），常用于**二进制文件**：

```c
size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *fp);
size_t fread(void *ptr, size_t size, size_t nmemb, FILE *fp);
```

- `ptr`：数据缓冲区
- `size`：每个数据项的字节数
- `nmemb`：数据项的个数
- 返回值：实际读/写的数据项个数

```c
// 写入整个数组
int a[100];
fwrite(a, sizeof(a[0]), 100, fp);

// 读取整个数组
fread(a, sizeof(a[0]), 100, fp);

// 写入结构体
struct Student s = {"Alice", 95};
fwrite(&s, sizeof(s), 1, fp);
```

<aside>
⚠️

用 `fwrite` 写入的数据是平台相关的（字节序、结构体对齐等），不适合跨平台交换数据。跨平台数据交换应使用文本格式或标准化的二进制格式。

</aside>

---

## 22.7 文件定位

### `fseek` 和 `ftell`

```c
int fseek(FILE *fp, long offset, int whence);
long ftell(FILE *fp);  // 返回当前位置
```

`whence` 参数：

| **常量** | **含义** |
| --- | --- |
| `SEEK_SET` | 从文件**开头**计算偏移 |
| `SEEK_CUR` | 从**当前位置**计算偏移 |
| `SEEK_END` | 从文件**末尾**计算偏移 |

```c
fseek(fp, 0L, SEEK_SET);    // 回到文件开头
fseek(fp, 0L, SEEK_END);    // 跳到文件末尾
fseek(fp, -10L, SEEK_CUR);  // 向前回退 10 个字节

long pos = ftell(fp);        // 记录当前位置
// ... 做一些操作 ...
fseek(fp, pos, SEEK_SET);   // 回到之前记录的位置
```

### `rewind`

```c
void rewind(FILE *fp);  // 等价于 fseek(fp, 0L, SEEK_SET) 并清除错误指示器
```

### `fgetpos` 和 `fsetpos`（处理大文件）

```c
int fgetpos(FILE *fp, fpos_t *pos);  // 获取当前位置
int fsetpos(FILE *fp, const fpos_t *pos);  // 设置位置
```

- `fpos_t` 类型可以表示比 `long` 更大的偏移量，适用于**大文件**
- 用 `fgetpos` 保存位置，用 `fsetpos` 恢复

<aside>
💡

对于文本文件，`fseek` 的 `offset` 应为 `0` 或 `ftell` 的返回值（配合 `SEEK_SET`），不要对文本文件使用任意偏移量，因为行尾转换可能导致位置不准确。二进制文件则没有此限制。

</aside>

---

## 22.8 字符串输入/输出（C99）

C99 提供了 `<stdio.h>` 中的 `sprintf`/`snprintf`/`sscanf`（见 22.3 节），此外还引入了 `vfprintf`、`vprintf`、`vsprintf` 等变参版本，用于编写自定义的格式化输出函数：

```c
#include <stdarg.h>
#include <stdio.h>

// 自定义错误输出函数
void error(const char *fmt, ...) {
    va_list ap;
    va_start(ap, fmt);
    fprintf(stderr, "Error: ");
    vfprintf(stderr, fmt, ap);
    fprintf(stderr, "\n");
    va_end(ap);
}
```

---

## 22.9 错误处理

### 错误指示器和文件结束指示器

每个流都有两个指示器：

- **错误指示器**：发生读写错误时置位
- **文件结束指示器（EOF 指示器）**：到达文件末尾时置位

```c
int feof(FILE *fp);     // 如果到达文件末尾，返回非零值
int ferror(FILE *fp);   // 如果发生错误，返回非零值
void clearerr(FILE *fp); // 清除两个指示器
```

<aside>
⚠️

不要用 `feof` 作为循环条件！`feof` 只有在**尝试读取超过末尾后**才返回真。正确做法是检查读取函数的返回值：

```c
// 错误写法
while (!feof(fp)) {
    fgets(line, sizeof(line), fp);  // 最后一次会读到空数据
}

// 正确写法
while (fgets(line, sizeof(line), fp) != NULL) {
    // 处理 line
}
```

</aside>

---

## 本章要点速查

| **概念** | **要点** |
| --- | --- |
| 流 | 对 I/O 设备的统一抽象，通过 `FILE *` 访问 |
| 标准流 | `stdin`（键盘）、`stdout`（屏幕）、`stderr`（屏幕，不受 `>` 重定向影响） |
| 文本 vs 二进制 | 文本模式自动转换行尾；二进制模式不做转换 |
| 打开/关闭 | `fopen`（必须检查 NULL）、`fclose`（刷新缓冲区） |
| 格式化 I/O | `printf`/`scanf` 系列，`sprintf`/`sscanf` 操作字符串 |
| 字符 I/O | `fgetc`/`fputc`，返回 `int` 以区分 `EOF` |
| 行 I/O | `fgets`（保留换行符，安全）、`fputs`；避免使用 `gets` |
| 块 I/O | `fread`/`fwrite`，适合数组和结构体，平台相关 |
| 文件定位 | `fseek`/`ftell`（小文件）、`fgetpos`/`fsetpos`（大文件）、`rewind` |
| 错误处理 | `feof`/`ferror`/`clearerr`；不要用 `feof` 做循环条件 |