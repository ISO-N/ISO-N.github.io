---
title: 第27章 C99对数学计算的新增支持
date: 2026-02-17 02:20:36
categories:
- [编程技术, C]
tags:
- C语言程序设计-现代方法
---
## 27.1 `<stdint.h>`：整数类型（C99）

`<stdint.h>` 定义了一组具有精确宽度和语义的整数类型，解决了传统整数类型（`int`、`long` 等）在不同平台上大小不一致的问题。

### 精确宽度整数类型

指定 **恰好** N 位宽的整数类型（可选，平台不支持则不提供）：

| 类型 | 说明 |
| --- | --- |
| `int8_t` / `uint8_t` | 恰好 8 位的有符号/无符号整数 |
| `int16_t` / `uint16_t` | 恰好 16 位 |
| `int32_t` / `uint32_t` | 恰好 32 位 |
| `int64_t` / `uint64_t` | 恰好 64 位 |

### 最小宽度整数类型

保证 **至少** N 位宽（必须提供）：

- `int_leastN_t` / `uint_leastN_t`（N = 8, 16, 32, 64）
- 例：`int_least32_t` 至少 32 位，但可能更宽

### 最快最小宽度整数类型

在至少 N 位宽的类型中选择 **运算最快** 的（必须提供）：

- `int_fastN_t` / `uint_fastN_t`（N = 8, 16, 32, 64）
- 例：`int_fast16_t` 至少 16 位，且在该平台上操作速度最快

### 最大宽度整数类型

- `intmax_t` / `uintmax_t` — 能表示任何整数类型的值的最宽整数类型

### 能保存指针的整数类型

- `intptr_t` / `uintptr_t` — 足够存储 `void *` 指针值的整数类型（可选）

### 限制值宏

每种类型都有对应的最小/最大值宏：

| 类型 | 最小值宏 | 最大值宏 |
| --- | --- | --- |
| `intN_t` | `INTN_MIN` | `INTN_MAX` |
| `uintN_t` | — | `UINTN_MAX` |
| `int_leastN_t` | `INT_LEASTN_MIN` | `INT_LEASTN_MAX` |
| `int_fastN_t` | `INT_FASTN_MIN` | `INT_FASTN_MAX` |
| `intmax_t` | `INTMAX_MIN` | `INTMAX_MAX` |
| `intptr_t` | `INTPTR_MIN` | `INTPTR_MAX` |

### 整数常量宏

用于创建指定类型的整数常量：

```c
INT8_C(value)    // 展开为 int_least8_t 类型的常量
UINT64_C(value)  // 展开为 uint_least64_t 类型的常量
INTMAX_C(value)  // 展开为 intmax_t 类型的常量
UINTMAX_C(value) // 展开为 uintmax_t 类型的常量
```

---

## 27.2 `<inttypes.h>`：整数类型的格式转换（C99）

`<inttypes.h>` 包含 `<stdint.h>` 并额外提供格式化 I/O 宏和最大宽度整数的算术函数。

### 格式化 I/O 宏

由于 `<stdint.h>` 中的类型在不同平台上可能映射到不同的底层类型，直接用 `%d`、`%ld` 等格式说明符会导致可移植性问题。`<inttypes.h>` 提供一系列宏来解决：

**`printf` 系列宏**（前缀 `PRI`）：

| 宏前缀 | 格式 | 示例 |
| --- | --- | --- |
| `PRIdN` | 有符号十进制 | `PRId32` → `"d"` 或 `"ld"` |
| `PRIiN` | 有符号整数 | `PRIi64` |
| `PRIoN` | 无符号八进制 | `PRIo16` |
| `PRIuN` | 无符号十进制 | `PRIu32` |
| `PRIxN` / `PRIXN` | 无符号十六进制 | `PRIx64` |
- N 可以是 8、16、32、64，也可以是 `LEAST8`、`FAST16`、`MAX`、`PTR` 等

```c
// 使用示例
int32_t val = 12345;
printf("val = %" PRId32 "\n", val);
```

**`scanf` 系列宏**（前缀 `SCN`）：用法与 `PRI` 系列类似

```c
int32_t x;
scanf("%" SCNd32, &x);
```

### `imaxdiv_t` 类型和相关函数

```c
intmax_t imaxabs(intmax_t j);           // 最大宽度整数的绝对值
imaxdiv_t imaxdiv(intmax_t numer, intmax_t denom); // 最大宽度整数的除法
```

- `imaxdiv_t` 结构包含 `quot`（商）和 `rem`（余数）成员

### 字符串与最大宽度整数的转换

```c
intmax_t strtoimax(const char *nptr, char **endptr, int base);
uintmax_t strtoumax(const char *nptr, char **endptr, int base);
intmax_t wcstoimax(const wchar_t *nptr, wchar_t **endptr, int base);
uintmax_t wcstoumax(const wchar_t *nptr, wchar_t **endptr, int base);
```

---

## 27.3 `<complex.h>`：复数运算（C99）

C99 将复数作为一等类型引入标准，`<complex.h>` 提供复数类型和丰富的操作函数。

### 复数类型

| 类型 | 说明 |
| --- | --- |
| `float _Complex` | 单精度复数 |
| `double _Complex` | 双精度复数 |
| `long double _Complex` | 扩展精度复数 |
- 包含 `<complex.h>` 后可用 `complex` 代替 `_Complex`（宏定义）
- `_Imaginary` 类型（纯虚数）是可选的，很多编译器不支持

### 构造复数

```c
#include <complex.h>

double complex z1 = 1.0 + 2.0 * I;  // 1 + 2i
double complex z2 = 3.0 - 4.0 * I;  // 3 - 4i

// I 是 <complex.h> 定义的宏，表示虚数单位 i
```

- `I` 宏展开为 `_Complex_I`（或 `_Imaginary_I`，如果支持）
- 复数支持 `+`、`-`、`*`、`/` 等算术运算符

### 提取实部和虚部

```c
double complex z = 1.0 + 2.0 * I;
double r = creal(z);  // 实部：1.0
double i = cimag(z);  // 虚部：2.0
```

| 函数 | `float` 版本 | `long double` 版本 |
| --- | --- | --- |
| `creal` | `crealf` | `creall` |
| `cimag` | `cimagf` | `cimagl` |

### 复数数学函数

- 三角函数

| 函数 | 说明 |
| --- | --- |
| `ccos` / `csin` / `ctan` | 复数余弦/正弦/正切 |
| `cacos` / `casin` / `catan` | 复数反余弦/反正弦/反正切 |
- 双曲函数

| 函数 | 说明 |
| --- | --- |
| `ccosh` / `csinh` / `ctanh` | 复数双曲余弦/正弦/正切 |
| `cacosh` / `casinh` / `catanh` | 复数反双曲余弦/反正弦/反正切 |
- 指数与对数

| 函数 | 说明 |
| --- | --- |
| `cexp` | 复数指数 $e^z$ |
| `clog` | 复数自然对数 |
- 幂函数与绝对值

| 函数 | 说明 |
| --- | --- |
| `cabs` | 复数绝对值（模）：$|z| = sqrt{x^2 + y^2}$ |
| `cpow` | 复数幂 $z_1^{z_2}$ |
| `csqrt` | 复数平方根 |
- 操作函数

| 函数 | 说明 |
| --- | --- |
| `carg` | 复数的辐角（argument），即极坐标角度 |
| `conj` | 复共轭：$overline{x+yi} = x-yi$ |
| `cproj` | Riemann 球面上的投影 |
- 所有复数函数都有 `f`（`float`）和 `l`（`long double`）后缀版本，如 `cabsf`、`cabsl`

---

## 27.4 `<tgmath.h>`：泛型数学（C99）

`<tgmath.h>` 提供 **类型通用（type-generic）** 的数学宏，使同一个宏名称能根据参数类型自动调用对应版本的函数。

### 动机

`<math.h>` 中每个函数都有三个版本：

```c
double      sin(double x);
float       sinf(float x);
long double sinl(long double x);
```

每次调用需手动选择正确版本，容易出错。`<tgmath.h>` 通过宏解决了这个问题。

### 使用方式

```c
#include <tgmath.h>

float f = 1.0f;
double d = 1.0;
long double ld = 1.0L;
float complex fc = 1.0f + 2.0f * I;

sin(f);   // 自动调用 sinf(f)
sin(d);   // 自动调用 sin(d)
sin(ld);  // 自动调用 sinl(ld)
sin(fc);  // 自动调用 csinf(fc)
```

### 类型选择规则

1. 如果参数是复数类型 → 调用 `<complex.h>` 中的对应函数
2. 如果参数是实数类型 → 调用 `<math.h>` 中的对应函数
3. 具体后缀由参数的浮点精度决定（`float` → `f` 后缀，`long double` → `l` 后缀，`double` → 无后缀）
4. 如果参数是整数类型 → 视为 `double`

### 覆盖的函数

- **同时覆盖实数和复数版本**的宏：

`acos`、`asin`、`atan`、`acosh`、`asinh`、`atanh`、`cos`、`sin`、`tan`、`cosh`、`sinh`、`tanh`、`exp`、`log`、`pow`、`sqrt`、`fabs`（复数版对应 `cabs`）

- **仅覆盖实数版本**的宏：

`atan2`、`cbrt`、`ceil`、`copysign`、`erf`、`erfc`、`exp2`、`expm1`、`fdim`、`floor`、`fma`、`fmax`、`fmin`、`fmod`、`frexp`、`hypot`、`ilogb`、`ldexp`、`lgamma`、`llrint`、`llround`、`log10`、`log1p`、`log2`、`logb`、`lrint`、`lround`、`nearbyint`、`nextafter`、`nexttoward`、`remainder`、`remquo`、`rint`、`round`、`scalbln`、`scalbn`、`tgamma`、`trunc`

- **仅覆盖复数版本**的宏：

`carg`、`cimag`、`conj`、`cproj`、`creal`

---

## 27.5 `<fenv.h>`：浮点环境（C99）

`<fenv.h>` 提供对 **浮点环境** 的访问和控制，包括浮点状态标志和控制模式。

### 核心概念

- **浮点状态标志（status flag）**：记录是否发生了某种浮点异常（如溢出、除以零等）
- **控制模式（control mode）**：控制浮点运算的行为（如舍入方向）
- **浮点环境（floating-point environment）** = 状态标志 + 控制模式

### 启用浮点环境访问

默认情况下编译器可能优化掉浮点环境的访问，需要使用 `#pragma` 启用：

```c
#pragma STDC FENV_ACCESS ON   // 启用
#pragma STDC FENV_ACCESS OFF  // 关闭（默认）
```

### 浮点异常

C99 定义了以下浮点异常宏：

| 宏 | 含义 | 示例 |
| --- | --- | --- |
| `FE_DIVBYZERO` | 除以零 | `1.0 / 0.0` |
| `FE_INEXACT` | 结果不精确（需要舍入） | `1.0 / 3.0` |
| `FE_INVALID` | 无效操作 | `0.0 / 0.0`、`sqrt(-1.0)` |
| `FE_OVERFLOW` | 上溢（结果太大） | `DBL_MAX * 2.0` |
| `FE_UNDERFLOW` | 下溢（结果太小） | `DBL_MIN / 2.0` |
| `FE_ALL_EXCEPT` | 所有异常的按位或 | — |
- 这些宏都是可选的；如果平台不支持某种异常，则不定义对应宏
- 可以用按位或组合多个异常：`FE_OVERFLOW | FE_UNDERFLOW`

### 异常处理函数

```c
// 清除指定的异常标志
int feclearexcept(int excepts);

// 获取指定异常标志的当前状态
int fegetexceptflag(fexcept_t *flagp, int excepts);

// 设置指定异常标志
int fesetexceptflag(const fexcept_t *flagp, int excepts);

// 引发指定的异常
int feraiseexcept(int excepts);

// 测试指定的异常标志是否已设置
int fetestexcept(int excepts);
```

```c
// 使用示例
feclearexcept(FE_ALL_EXCEPT);  // 清除所有异常标志
// ... 执行浮点运算 ...
if (fetestexcept(FE_OVERFLOW)) {
    printf("发生了上溢!\n");
}
```

### 舍入模式

C99 支持四种舍入方向：

| 宏 | 含义 |
| --- | --- |
| `FE_TONEAREST` | 向最近的可表示值舍入（默认） |
| `FE_DOWNWARD` | 向负无穷方向舍入 |
| `FE_UPWARD` | 向正无穷方向舍入 |
| `FE_TOWARDZERO` | 向零方向舍入（截断） |

```c
int fegetround(void);          // 获取当前舍入方向
int fesetround(int round);     // 设置舍入方向

// 使用示例
int old_round = fegetround();
fesetround(FE_UPWARD);         // 设置为向上舍入
// ... 执行计算 ...
fesetround(old_round);         // 恢复原来的舍入方向
```

### 保存和恢复浮点环境

```c
// 获取当前浮点环境
int fegetenv(fenv_t *envp);

// 设置浮点环境
int fesetenv(const fenv_t *envp);

// 保存当前环境，清除异常标志，安装非停止模式
int feholdexcept(fenv_t *envp);

// 恢复环境，但保留当前已引发的异常
int feupdateenv(const fenv_t *envp);
```

- `FE_DFL_ENV` — 指向默认浮点环境的指针，可用于恢复到初始状态

```c
// 典型用法：临时修改浮点环境
fenv_t saved_env;
feholdexcept(&saved_env);   // 保存当前环境并进入非停止模式
// ... 执行可能引发异常的浮点运算 ...
feupdateenv(&saved_env);    // 恢复环境，保留新引发的异常
```

---

## 27.6 `<math.h>` 的 C99 新增内容

C99 对 `<math.h>` 进行了大幅扩充，新增了大量数学函数和宏。

### 浮点类型分类宏

```c
int fpclassify(x);  // 返回浮点数的分类
int isfinite(x);    // 是否为有限数
int isinf(x);       // 是否为无穷大
int isnan(x);       // 是否为 NaN
int isnormal(x);    // 是否为规格化数
int signbit(x);     // 符号位是否设置
```

分类值：

| 宏 | 含义 |
| --- | --- |
| `FP_INFINITE` | 正或负无穷大 |
| `FP_NAN` | 非数值（NaN） |
| `FP_NORMAL` | 规格化数 |
| `FP_SUBNORMAL` | 非规格化数（接近零的极小数） |
| `FP_ZERO` | 正零或负零 |

### 新增数学函数

- 指数与对数

| 函数 | 说明 |
| --- | --- |
| `exp2(x)` | $2^x$ |
| `expm1(x)` | $e^x - 1$（x 接近 0 时精度更高） |
| `log2(x)` | $\log_2 x$ |
| `log1p(x)` | $ln(1+x)$（x 接近 0 时精度更高） |
| `logb(x)` | 提取 x 的指数部分（以 `FLT_RADIX` 为底的对数） |
| `ilogb(x)` | 与 `logb` 相同，但返回 `int` |
| `scalbn(x, n)` / `scalbln(x, n)` | $x times FLT_RADIX^n$（高效） |
- 幂函数与根

| 函数 | 说明 |
| --- | --- |
| `cbrt(x)` | 立方根 $\sqrt\[3\]{x}$ |
| `hypot(x, y)` | $sqrt{x^2 + y^2}$（避免溢出） |
- 误差函数与伽马函数

| 函数 | 说明 |
| --- | --- |
| `erf(x)` | 误差函数 |
| `erfc(x)` | 互补误差函数 $1 - erf(x)$ |
| `tgamma(x)` | 伽马函数 $\Gamma(x)$ |
| `lgamma(x)` | $\ln\|\Gamma(x)\|$ |
- 舍入与取整

| 函数 | 说明 |
| --- | --- |
| `round(x)` | 四舍五入到最近整数（中间值远离零） |
| `lround(x)` / `llround(x)` | 与 `round` 相同，返回 `long` / `long long` |
| `trunc(x)` | 向零截断取整 |
| `rint(x)` | 按当前舍入模式取整（可能引发 `FE_INEXACT`） |
| `lrint(x)` / `llrint(x)` | 与 `rint` 相同，返回 `long` / `long long` |
| `nearbyint(x)` | 按当前舍入模式取整（不引发 `FE_INEXACT`） |
- 求余与分解

| 函数 | 说明 |
| --- | --- |
| `remainder(x, y)` | IEEE 求余（结果可为负） |
| `remquo(x, y, &quo)` | 求余并获取商的低位 |
| `nan("string")` | 生成 quiet NaN |
- 最值与差

| 函数 | 说明 |
| --- | --- |
| `fmax(x, y)` | 返回较大值（忽略 NaN） |
| `fmin(x, y)` | 返回较小值（忽略 NaN） |
| `fdim(x, y)` | 正差：$max(x-y, 0)$ |
- 浮点操作

| 函数 | 说明 |
| --- | --- |
| `copysign(x, y)` | 返回 x 的绝对值带 y 的符号 |
| `nextafter(x, y)` | x 向 y 方向的下一个可表示的浮点数 |
| `nexttoward(x, y)` | 与 `nextafter` 类似，但 y 为 `long double` |
- 融合乘加

```c
double fma(double x, double y, double z);  // 计算 x*y + z（一次舍入，精度更高）
```

- `FP_FAST_FMA` 宏定义时，表明 `fma` 的速度不低于分别计算乘法和加法

### 比较宏

C99 提供了一组 **不引发浮点异常** 的比较宏（适用于可能含 NaN 的操作数）：

| 宏 | 等价于 |
| --- | --- |
| `isgreater(x, y)` | `x > y` |
| `isgreaterequal(x, y)` | `x >= y` |
| `isless(x, y)` | `x < y` |
| `islessequal(x, y)` | `x <= y` |
| `islessgreater(x, y)` | `x < y \|\| x > y` |
| `isunordered(x, y)` | x 或 y 是否为 NaN |
- 普通的 `<`、`>` 等运算符在操作数包含 NaN 时会引发无效操作异常，而这些宏不会