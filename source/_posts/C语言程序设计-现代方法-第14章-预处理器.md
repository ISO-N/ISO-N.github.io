---
title: 第14章 预处理器
date: 2026-02-17 02:20:27
categories:
- [编程技术, C]
tags:
- C语言程序设计-现代方法
---
## 14.1 预处理器的工作原理

- 预处理器（preprocessor）在**编译之前**对程序进行文本处理
- 预处理器的输入是 C 程序，输出是**编辑后的 C 程序**（不含预处理指令）
- 预处理器执行的操作包括：宏定义、文件包含、条件编译等
- 预处理指令以 `#` 开头，指令末尾**不加分号**

### 预处理指令通用规则

- 指令都以 `#` 开头，`#` 前可以有空白字符
- 指令中的符号之间可以插入任意数量的空格和制表符
- 指令总是在**第一个换行符处结束**，除非使用 `\` 续行
- 指令可以出现在程序中的**任何位置**
- 注释可以和指令放在同一行

---

## 14.2 预处理指令一览

| **指令** | **用途** |
| --- | --- |
| `#define` | 定义宏 |
| `#undef` | 取消宏定义 |
| `#include` | 包含头文件 |
| `#if` / `#ifdef` / `#ifndef` | 条件编译 |
| `#elif` / `#else` / `#endif` | 条件编译分支 |
| `#error` | 产生编译错误信息 |
| `#line` | 修改行号和文件名 |
| `#pragma` | 向编译器发送特殊指令 |

---

## 14.3 宏定义（#define）

### 简单的宏（对象式宏）

用 `#define` 为常量或表达式定义名称：

```c
#define N 100
#define PI 3.14159
#define TRUE 1
#define FALSE 0
```

- 预处理器会将后续代码中所有 `N` 替换为 `100`（纯文本替换）
- 宏的名称通常全部**大写**，以区分普通变量
- 宏定义中可以使用前面定义的宏：

```c
#define BUFFER_SIZE 1024
#define MAX_BUFFER (2 * BUFFER_SIZE)
```

<aside>
⚠️

宏只是**文本替换**，不是赋值。`#define N 100` 不等同于 `const int N = 100;`，宏没有类型、没有作用域。

</aside>

### 宏定义中的圆括号

在宏定义中使用**圆括号**非常重要，可以避免运算符优先级导致的错误：

```c
#define TWO_PI (2 * 3.14159)     // ✅ 加括号
#define TWO_PI 2 * 3.14159       // ❌ 有风险
```

如果不加括号：

```c
// 假设 #define TWO_PI 2 * 3.14159
double x = TWO_PI / 2;
// 展开为: double x = 2 * 3.14159 / 2;  → 结果是 3.14159，不是 PI！
```

### 带参数的宏（函数式宏）

宏可以带参数，类似函数调用：

```c
#define MAX(x, y)   ((x) > (y) ? (x) : (y))
#define IS_EVEN(n)  ((n) % 2 == 0)
```

调用方式：

```c
int z = MAX(a, b);       // 展开为 ((a) > (b) ? (a) : (b))
if (IS_EVEN(k)) { ... }  // 展开为 ((k) % 2 == 0)
```

<aside>
⚠️

**宏名和左括号之间不能有空格！** 否则预处理器会把 `(x, y)` 当作替换体的一部分：

```c
#define MAX (x, y)  ((x) > (y) ? (x) : (y))   // ❌ 错误！
#define MAX(x, y)   ((x) > (y) ? (x) : (y))   // ✅ 正确
```

</aside>

### 函数式宏的陷阱

- **参数要加括号**，替换体整体也要加括号：

```c
#define SQUARE(x) x * x           // ❌ 危险
#define SQUARE(x) ((x) * (x))     // ✅ 安全

// 不加括号时:
SQUARE(a + 1)  →  a + 1 * a + 1  →  a + a + 1  // 错误！
// 加括号后:
SQUARE(a + 1)  →  ((a + 1) * (a + 1))            // 正确
```

- **参数有副作用时要小心**（参数可能被求值多次）：

```c
SQUARE(i++)  →  ((i++) * (i++))   // i 被自增两次！未定义行为
```

<aside>
💡

函数式宏的优势：

- 程序可能**更快**（避免函数调用开销）
- 更**通用**（宏的参数没有类型限制，`MAX` 对 `int`、`double` 等都适用）

劣势：

- 编译后代码可能**更大**（每次调用都展开）
- 参数**没有类型检查**
- 无法用指针指向宏
- 参数可能被**多次求值**
</aside>

### `#` 运算符（字符串化）

在宏定义中，`#` 可以将参数转换为**字符串字面量**：

```c
#define PRINT_INT(n) printf(#n " = %d\n", n)

PRINT_INT(x);
// 展开为: printf("x" " = %d\n", x);
// 等价于: printf("x = %d\n", x);
```

### `##` 运算符（记号粘合）

`##` 将两个记号**拼接**成一个记号：

```c
#define GENERIC_MAX(type)        \
type type##_max(type x, type y)  \
{                                \
    return (x > y) ? x : y;     \
}

GENERIC_MAX(int)
// 展开为:
// int int_max(int x, int y) { return (x > y) ? x : y; }
```

- `type##_max` 在 `type` 为 `int` 时变成 `int_max`
- 这是 C 语言中实现"泛型"的一种技巧

### 宏的通用属性

- 宏的**替换列表**可以包含对其他宏的调用，预处理器会**反复扫描**直到没有更多宏可替换
- 宏**不可以递归定义**自身
- 预处理器只替换**完整的记号**，不替换字符串字面量、字符常量或标识符的一部分

### `#undef` 取消宏定义

```c
#define N 100
// ... 使用 N ...
#undef N
// 此后 N 不再是宏
```

- 常用于在使用某个名称作变量前，确保它不是宏

---

## 14.4 条件编译

条件编译让预处理器根据条件**决定包含或排除**一段代码。

### `#if` 和 `#endif`

```c
#if 常量表达式
    // 当表达式非零时包含这段代码
#endif
```

示例：

```c
#define DEBUG 1

#if DEBUG
    printf("Debug: x = %d\n", x);
#endif
```

### `#ifdef` 和 `#ifndef`

```c
#ifdef 宏名      // 如果宏已定义
    // ...
#endif

#ifndef 宏名     // 如果宏未定义
    // ...
#endif
```

- `#ifdef FOO` 等价于 `#if defined(FOO)`
- `#ifndef FOO` 等价于 `#if !defined(FOO)`

### `#elif` 和 `#else`

```c
#if 表达式1
    // ...
#elif 表达式2
    // ...
#elif 表达式3
    // ...
#else
    // ...
#endif
```

### `defined` 运算符

`defined` 运算符在 `#if` 中测试宏是否已定义：

```c
#if defined(WIN32) || defined(_WIN64)
    // Windows 平台代码
#elif defined(__linux__)
    // Linux 平台代码
#else
    // 其他平台
#endif
```

### 条件编译的常见用途

**1. 调试代码的开关**

```c
#define DEBUG 1

#if DEBUG
    printf("Entering function foo, x = %d\n", x);
#endif
```

**2. 头文件保护（防止重复包含）**

```c
// money.h
#ifndef MONEY_H
#define MONEY_H

// 头文件内容...

#endif
```

- 这是最经典、最重要的条件编译用法
- 确保头文件内容只被编译一次，避免重复定义错误

**3. 跨平台代码**

```c
#if defined(_WIN32)
    #include <windows.h>
#elif defined(__linux__)
    #include <unistd.h>
#endif
```

**4. 临时屏蔽代码**

```c
#if 0
    // 这段代码被"注释掉"了
    // 比 /* */ 更安全，因为可以嵌套
#endif
```

---

## 14.5 其他指令

### `#error`

遇到 `#error` 时，预处理器会产生一条**错误信息**并终止编译：

```c
#if INT_MAX < 100000
    #error int type is too small
#endif
```

- 通常与条件编译搭配使用，在不满足编译条件时报错

### `#line`

修改编译器认为的**当前行号**和**文件名**：

```c
#line 100            // 下一行行号变为 100
#line 100 "foo.c"    // 行号变为 100，文件名变为 foo.c
```

- 主要被自动生成 C 代码的工具使用，普通程序员很少用到

### `#pragma`

向编译器发送**特殊指令**，行为因编译器而异：

```c
#pragma warning(disable: 4996)    // MSVC: 禁用特定警告
#pragma pack(1)                    // 设置结构体对齐方式
#pragma once                       // 防止头文件重复包含（非标准但广泛支持）
```

- C89 标准规定编译器**忽略不认识**的 `#pragma`，不会报错

---

## 14.6 预定义宏

C 语言提供了一些**内置宏**，无需 `#define` 即可使用：

| **宏** | **含义** | **示例值** |
| --- | --- | --- |
| `__LINE__` | 当前行号 | `42` |
| `__FILE__` | 当前文件名 | `"main.c"` |
| `__DATE__` | 编译日期 | `"Feb 13 2026"` |
| `__TIME__` | 编译时间 | `"10:30:00"` |
| `__STDC__` | 是否符合 C 标准 | `1` |

使用示例：

```c
// 调试辅助
#define DEBUG_PRINT(msg) \
    printf("[%s:%d] %s\n", __FILE__, __LINE__, msg)

DEBUG_PRINT("reached here");
// 输出: [main.c:25] reached here
```

---

## 本章要点速查

| **概念** | **要点** |
| --- | --- |
| 预处理器本质 | 编译前的**文本替换**工具，指令以 `#` 开头，不加分号 |
| 对象式宏 | `#define N 100`，用于定义常量，替换体建议加括号 |
| 函数式宏 | `#define F(x) ((x)*(x))`，参数和整体都要加括号，注意多次求值 |
| `#` 和 `##` | `#` 字符串化参数；`##` 粘合两个记号 |
| 条件编译 | `#if` / `#ifdef` / `#ifndef`  • `#elif` / `#else`  • `#endif` |
| 头文件保护 | `#ifndef X_H` / `#define X_H` / `#endif` 防止重复包含 |
| 预定义宏 | `__LINE__`、`__FILE__`、`__DATE__`、`__TIME__`、`__STDC__` |