---
title: 第18章 声明
date: 2026-02-17 02:20:30
categories:
- [编程技术, C]
tags:
- C语言程序设计-现代方法
---
## 18.1 声明的语法

C 语言中，**声明**（declaration）用于向编译器描述变量、函数或类型的特征。声明的一般形式为：

```
声明说明符 声明符;
```

- **声明说明符**（declaration specifiers）：描述声明的属性，包括存储类型、类型限定符、类型说明符
- **声明符**（declarators）：给出被声明对象的名称以及附加的类型信息（如 `*`、`[]`、`()`）

```c
static const int *p;
// static      → 存储类型
// const       → 类型限定符
// int         → 类型说明符
// *p          → 声明符
```

### 声明说明符的组成

声明说明符由以下三类组成，**顺序不限**但通常按如下惯例排列：

1. **存储类型**（storage class）：`auto`、`static`、`extern`、`register`（至多一个）
2. **类型限定符**（type qualifier）：`const`、`volatile`、`restrict`（C99）
3. **类型说明符**（type specifier）：`int`、`char`、`float`、`double`、`void`、结构/联合/枚举名等

<aside>
📌

声明说明符的顺序在语法上没有限制，`const static int` 和 `static const int` 等价。但推荐按 **存储类型 → 类型限定符 → 类型说明符** 的顺序书写，以提高可读性。

</aside>

## 18.2 存储类型

存储类型决定了变量的**存储期**（lifetime）和**链接**（linkage）。

### auto

- 只能用于**块作用域**的变量（局部变量）
- 变量在进入所在块时创建，退出时销毁（**自动存储期**）
- 默认情况下局部变量就是 `auto`，因此这个关键字**几乎不使用**

```c
void f(void) {
    auto int i;   // 等价于 int i;
}
```

### static

`static` 有两种用途：

**1. 用于局部变量：** 使变量具有**静态存储期**，即函数返回后变量仍然存在，下次调用时保留上次的值：

```c
void count_calls(void) {
    static int count = 0;   // 只在程序启动时初始化一次
    count++;
    printf("调用了 %d 次\n", count);
}
```

**2. 用于全局变量或函数：** 将其链接从**外部链接**变为**内部链接**，使其只在**当前文件**内可见：

```c
static int file_var = 10;      // 只在本文件可见
static void helper(void) { }   // 只在本文件可见
```

<aside>
💡

利用 `static` 隐藏全局变量和辅助函数，是 C 语言实现**信息隐藏**和**模块化**的重要手段。

</aside>

### extern

- 声明一个变量或函数是在**其他地方定义**的（外部链接）
- `extern` 声明**不分配存储空间**，只是告诉编译器该名字存在

```c
// file1.c
int shared = 42;          // 定义

// file2.c
extern int shared;         // 声明（引用 file1.c 中的定义）
```

<aside>
⚠️

一个变量只能有**一个定义**，但可以有**多个** `extern` 声明。如果 `extern` 声明带有初始化器，它就变成了**定义**：

```c
extern int x = 10;   // 这是定义，不是单纯的声明
```

</aside>

### register

- 建议编译器将变量存放在**寄存器**中以加快访问速度
- 只能用于**局部变量**和**函数参数**
- `register` 变量**不能取地址**（不能使用 `&`）
- 现代编译器的优化能力很强，通常**忽略** `register` 建议

```c
register int i;
for (i = 0; i < 10000; i++) {
    // 编译器可能（也可能不）将 i 放入寄存器
}
```

### 存储类型总结

| 存储类型 | 适用范围 | 存储期 | 默认链接 |
| --- | --- | --- | --- |
| `auto` | 局部变量 | 自动 | 无链接 |
| `static`（局部） | 局部变量 | 静态 | 无链接 |
| `static`（全局） | 全局变量/函数 | 静态 | 内部链接 |
| `extern` | 全局变量/函数 | 静态 | 外部链接 |
| `register` | 局部变量 | 自动 | 无链接 |

## 18.3 类型限定符

### const

`const` 表示变量的值在初始化后**不可修改**：

```c
const int MAX = 100;
MAX = 200;            // ❌ 编译错误
```

`const` 与指针的组合需要注意 `const` 修饰的位置：

```c
const int *p;         // 指向 const int 的指针（不能通过 p 修改所指的值）
int *const p;         // const 指针（p 本身不能修改，但所指的值可以修改）
const int *const p;   // 都不能修改
```

<aside>
💡

阅读技巧：**从右往左读**。`const int *p` → "`p` 是指针，指向 `const int`"；`int *const p` → "`p` 是 `const` 指针，指向 `int`"。

</aside>

### volatile

`volatile` 告诉编译器：变量的值可能被**程序以外的因素**（如硬件、中断、其他线程）改变，编译器**不应对其进行优化**：

```c
volatile int sensor_value;   // 每次都从内存读取，不使用缓存值
```

典型用途：

- 硬件寄存器映射
- 信号处理函数中修改的变量
- 多线程共享变量（但 `volatile` 不能替代互斥锁）

### restrict（C99）

`restrict` 只能用于**指针**，表示该指针是访问其所指对象的**唯一途径**。这给编译器提供了更多**优化空间**：

```c
void copy(int *restrict dest, const int *restrict src, int n) {
    for (int i = 0; i < n; i++)
        dest[i] = src[i];
}
```

<aside>
📌

`restrict` 是对编译器的**承诺**，如果程序员违反了这个承诺（即通过其他指针访问了同一对象），结果是**未定义行为**。标准库中的 `memcpy` 使用 `restrict`，而 `memmove` 不使用，因此 `memcpy` 不能处理重叠区域。

</aside>

## 18.4 声明符

声明符指定被声明对象的**名称**以及额外的类型信息。声明符可以嵌套组合，从简单到复杂：

### 简单声明符

```c
int i;            // i 是 int
```

### 指针声明符

```c
int *p;           // p 是指向 int 的指针
int **pp;         // pp 是指向 int 指针的指针
```

### 数组声明符

```c
int a[10];        // a 是含 10 个 int 的数组
int b[3][4];      // b 是 3×4 的二维数组
```

### 函数声明符

```c
int f(int, double);       // f 是函数，接受 int 和 double，返回 int
int (*pf)(int, double);   // pf 是指向上述函数类型的指针
```

### 复杂声明的解读

复杂声明遵循**由内向外、右左交替**的规则：

```c
int (*a[5])(int);
```

解读过程：

1. `a` → 名字是 `a`
2. `a[5]` → `a` 是大小为 5 的数组
3. `(*a[5])` → 数组的元素是指针
4. `(*a[5])(int)` → 指针指向接受 `int` 参数的函数
5. `int (*a[5])(int)` → 该函数返回 `int`

**完整解读：** `a` 是一个包含 5 个元素的数组，每个元素是指向"接受 `int` 参数并返回 `int`"的函数指针。

<aside>
💡

解读复杂声明的口诀：**从变量名出发，先右后左，遇到括号就转向**。也可以借助 `cdecl` 工具将 C 声明翻译成英文。

</aside>

## 18.5 初始化器

### 简单变量的初始化

```c
int i = 10;
double d = 3.14;
```

### 不同存储期变量的初始化规则

- **静态存储期**（全局变量、`static` 局部变量）：
    - 默认初始化为 **0**（或 `NULL`、`0.0`）
    - 初始化器必须是**常量表达式**
- **自动存储期**（普通局部变量）：
    - **没有默认值**，不初始化则值不确定
    - 初始化器可以是任意表达式

```c
int g;                   // 全局，默认为 0
static int s;            // static 局部，默认为 0

void f(void) {
    int x;               // 局部，值不确定！
    int y = g + 1;       // 可以用表达式初始化
}
```

<aside>
⚠️

使用未初始化的局部变量是**未定义行为**。始终养成在声明时就初始化的习惯。

</aside>

### 数组的初始化

```c
int a[5] = {1, 2, 3, 4, 5};         // 完全初始化
int b[5] = {1, 2};                   // b[2]~b[4] 为 0
int c[] = {1, 2, 3};                 // 编译器推断长度为 3
```

### 结构体的初始化

```c
struct point { int x, y; };

struct point p1 = {10, 20};          // 按成员顺序初始化
struct point p2 = {.y = 20, .x = 10}; // C99 指定初始化器
```

### C99 指定初始化器

C99 允许在初始化数组和结构体时**指定**要初始化的成员：

```c
// 数组
int a[10] = {[3] = 30, [7] = 70};

// 结构体
struct point p = {.x = 5, .y = 10};
```

- 未指定的成员自动初始化为 0
- 指定初始化器可以与普通初始化器混合使用

## 18.6 内联函数（C99）

### inline 关键字

C99 引入 `inline` 关键字，**建议**编译器将函数调用替换为函数体（内联展开），以减少函数调用开销：

```c
inline int square(int x) {
    return x * x;
}
```

### 内联函数的特点

- `inline` 只是**建议**，编译器可以忽略
- 内联函数通常放在**头文件**中，因为编译器需要在调用处看到函数体
- 适合**短小、频繁调用**的函数

### 内联函数与宏的比较

| 特性 | 内联函数 | 宏 (`#define`) |
| --- | --- | --- |
| 类型检查 | ✅ 有 | ❌ 无 |
| 参数求值 | 只求值一次 | 可能多次求值 |
| 调试 | 支持 | 困难 |
| 作用域 | 遵循作用域规则 | 简单文本替换 |

<aside>
📌

C99 的 `inline` 与 C++ 的 `inline` 语义有所不同。C99 中，如果一个 `inline` 函数在某个翻译单元中没有被声明为 `extern`，则该翻译单元中的定义称为**内联定义**，不会为该函数生成外部可见的代码。要生成外部定义，需要在某个 `.c` 文件中加上 `extern` 声明。

</aside>

### 外部定义的写法

```c
// square.h
inline int square(int x) {
    return x * x;
}

// square.c（提供外部定义）
#include "square.h"
extern int square(int x);   // 使编译器生成外部可见的函数体
```

## 18.7 小结

| 概念 | 关键字 | 作用 |
| --- | --- | --- |
| 存储类型 | `auto` `static` `extern` `register` | 控制存储期和链接 |
| 类型限定符 | `const` `volatile` `restrict` | 限制变量的使用方式 |
| 声明符 | `*` `[]` `()` | 组合构造复杂类型 |
| 初始化器 | `=` `{}` | 在声明时赋初值 |
| 内联函数 | `inline` | 建议编译器内联展开 |

> 声明是 C 程序的基础。关键要点：理解**存储类型**对变量生命周期和可见性的影响、掌握 `const` 与指针的组合规则、学会用"**右左法则**"解读复杂声明、注意不同存储期变量的**初始化差异**。
>