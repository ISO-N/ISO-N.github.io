---
title: 第13章 不常见的数据类型
date: 2026-02-17 15:25:02
categories:
- [软件工程, 理论]
tags:
- 代码大全
---
本章讨论几种在多数高级语言中不太常用、但在特定场景下非常有用的数据类型：**结构体**、**指针**、**全局数据**。

---

## 13.1 结构体（Structures）

结构体将一组相关的数据组织在一起，作为一个整体来操作。

- **用结构体来明确数据关系**：把逻辑上相关的数据放进同一个结构体，而非散落为一堆松散变量
- **简化函数参数**：当一个函数需要传递多个相关参数时，可以将它们打包成一个结构体传入，减少参数数量
- **降低维护成本**：修改数据组织时，只需改结构体定义和少数访问代码，而不是遍布全程序的变量
- **结构体可以使代码更清晰**：[`employee.name`](http://employee.name) 比单独的 `employeeName` 更能体现数据之间的层次关系
- **简化对数据块的操作**：对结构体进行复制、比较等操作比分别处理多个变量更简洁

> **核心原则**：如果你总是同时使用一组变量，就应该考虑把它们放进一个结构体。
> 

---

## 13.2 指针（Pointers）

指针是编程中最容易出错的领域之一。本节提供了一系列使用指针的策略和防御措施。

### 理解指针

- 指针本质上包含两层含义：**指针变量本身**（存放地址的那块内存）和**它所指向的内容**
- 理解指针的关键在于区分 *地址*（location）和 *值*（value）

### 使用指针的一般技巧

- **把指针操作限制在子程序或类中**：将指针的分配和释放封装起来，避免暴露给调用方
- **在声明指针的同时初始化它**：未初始化的指针是常见 bug 来源
- **在使用指针之前检查它**：用前先判断是否为 `null`/`nil`
- **先检查指针所指向的变量再使用**：确认指向的内存有效
- **用"狗牌"字段（tag field）来检测损坏的内存**：在分配的内存块首尾添加标记值，释放时检查是否被改写
- **释放指针后将其置空**：`delete p; p = nullptr;` 避免悬空指针
- **在删除或释放指针之前先检查是否有效**
- **跟踪指针的分配情况**：维护一个已分配指针的列表，有助于检测内存泄漏
- **编写覆盖子程序来集中管理指针操作**：用自定义的 `SAFE_NEW` 和 `SAFE_DELETE` 替代裸指针操作
- **用额外的指针变量来提高代码清晰度**：用具有描述性名称的临时指针变量，避免复杂的指针表达式
- **用非指针技术来简化问题**：如果不是必须用指针，就不要用

### C++ 指针的特定建议

- 使用**智能指针**（`unique_ptr`、`shared_ptr`）代替裸指针
- 用**引用**代替指针来传递参数（引用不可能为空）
- 使用 `const` 指针来防止通过指针意外修改数据
- 注意 `*` 和 `++` 等运算符在指针上下文中的优先级问题

### C 指针的特定建议

- 使用类型转换（cast）要格外谨慎
- 遵循 `*p++` vs `(*p)++` 的区分约定
- 用 `sizeof()` 来确定内存分配大小，避免手动计算

---

## 13.3 全局数据（Global Data）

全局数据是最容易被滥用的特性之一，但在某些场合它也有合理的用途。

### 全局数据的常见问题

- **难以追踪修改来源**：任何代码都可能在任何时候修改全局变量，调试非常困难
- **代码复用困难**：子程序依赖全局数据后，很难独立抽取复用
- **妨碍模块化**：全局数据破坏了模块之间的边界
- **命名空间污染**：全局变量增加了命名冲突的风险
- **阻碍测试**：每次测试前可能需要重置全局状态
- **多线程不安全**：多个线程同时读写全局数据容易导致竞态条件

### 使用全局数据的合理场景

- **保存全局数值**：如程序级别的配置常量
- **模拟具名常量**：在不支持常量的语言中，可以用全局数据配合命名约定来模拟
- **模拟枚举类型**
- **简化对极其常用数据的使用**：当某个数据确实被大量模块频繁使用时

### 如果必须使用全局数据

- **创建一个访问子程序来控制读写**：不要直接访问全局变量，通过 getter/setter 访问，便于以后修改底层实现
- **把所有全局数据放在一个统一的位置**：集中管理，便于查找和维护
- **使用访问子程序来代替全局数据**：将全局变量隐藏在模块内部，只通过子程序暴露
- **用命名约定来区分全局变量**：如添加 `g_` 前缀
- **建立一份全局数据清单**：记录每个全局变量的用途和修改者

---

## 13.4 本章核心检查清单

### 结构体

- [ ]  是否用结构体来组织相关数据？
- [ ]  是否考虑用结构体简化参数列表？

### 指针

- [ ]  指针操作是否被隔离在子程序中？
- [ ]  指针在声明时是否同时初始化？
- [ ]  使用指针前是否做了有效性检查？
- [ ]  释放后是否将指针置空？
- [ ]  代码是否使用了必要数量的指针变量来提高可读性？
- [ ]  链表中的指针是否按正确的顺序释放？
- [ ]  程序是否使用了某种技术来追踪内存分配？

### 全局数据

- [ ]  是否已排除所有不必要的全局变量？
- [ ]  全局数据是否通过访问子程序来访问？
- [ ]  全局变量是否有统一的命名约定和集中管理？

---

## 要点总结

- **结构体**可以让相关数据的关系更加清晰、代码更加简洁
- **指针**容易出错，核心防御策略是：封装、初始化、检查、置空
- **全局数据**应当尽量避免；如果必须使用，请通过访问子程序来封装访问