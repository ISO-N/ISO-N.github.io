---
title: 第17章 指针的高级应用
date: 2026-02-17 02:20:29
categories:
- [编程技术, C]
---
## 17.1 动态存储分配

C 语言的数据结构通常在编译时就确定了大小。**动态存储分配**允许程序在**运行时**按需分配内存，解决了编译时无法确定数据量的问题。

### 内存分配函数

C 语言在 `<stdlib.h>` 中提供了三个内存分配函数：

| 函数 | 用途 |
| --- | --- |
| `malloc` | 分配一块内存，**不初始化** |
| `calloc` | 分配一块内存，**自动清零** |
| `realloc` | **调整**已分配内存块的大小 |

这三个函数都返回 `void *` 类型的指针（通用指针），如果分配失败则返回 **`NULL`**。

### 空指针

**空指针**（null pointer）是一个"不指向任何对象"的特殊指针。

```c
int *p = NULL;     // p 不指向任何对象
if (p == NULL)     // 检测空指针
    printf("p is a null pointer\n");
```

- `NULL` 是宏，定义在 `<stddef.h>`、`<stdlib.h>` 等多个头文件中
- 在需要布尔值的地方，空指针被视为"假"，非空指针被视为"真"：

```c
if (p)      // 等价于 if (p != NULL)
if (!p)     // 等价于 if (p == NULL)
```

<aside>
⚠️

使用 `malloc` 等函数后，**必须检查返回值是否为 NULL**。在内存不足时，分配函数会返回 NULL，若不检查直接使用将导致**未定义行为**。

</aside>

---

## 17.2 动态分配字符串

### 使用 malloc 为字符串分配内存

`malloc` 的原型：

```c
void *malloc(size_t size);
```

为字符串分配内存时，别忘了为**空字符 `\0`** 多分配一个字节：

```c
char *p = malloc(n + 1);   // 为 n 个字符的字符串分配空间
```

<aside>
📌

`malloc` 返回 `void *`，C 语言中可以直接赋给任何指针类型，**不需要强制类型转换**。但 C++ 中需要转换。

</aside>

### 动态分配字符串的函数

一个常见的工具函数——复制字符串（许多编译器提供非标准的 `strdup`，这里是手动实现）：

```c
char *my_strdup(const char *s)
{
    char *p = malloc(strlen(s) + 1);
    if (p == NULL)
        return NULL;       // 分配失败
    strcpy(p, s);
    return p;
}
```

### 在动态分配的字符串中使用 malloc

动态分配使得函数可以返回一个"新创建的"字符串，调用者负责在不再需要时释放它。

```c
char *concat(const char *s1, const char *s2)
{
    char *result = malloc(strlen(s1) + strlen(s2) + 1);
    if (result == NULL)
        return NULL;
    strcpy(result, s1);
    strcat(result, s2);
    return result;
}
```

---

## 17.3 动态分配数组

### 使用 malloc 分配数组

```c
int *a = malloc(n * sizeof(int));   // 分配 n 个 int 的数组
for (int i = 0; i < n; i++)
    a[i] = 0;                       // 初始化
```

分配后就可以像使用普通数组一样使用 `a[i]`（因为 C 语言中数组下标运算本质上是指针运算）。

### 使用 calloc 分配数组

`calloc` 的原型：

```c
void *calloc(size_t nmemb, size_t size);
```

`calloc` 与 `malloc` 的区别：

- 参数不同：`calloc` 接受**元素个数**和**每个元素的大小**两个参数
- `calloc` 会将分配的内存**全部清零**

```c
int *a = calloc(n, sizeof(int));
// 等价于 malloc + memset 清零，a[0]~a[n-1] 全为 0
```

### 使用 realloc 调整数组大小

`realloc` 的原型：

```c
void *realloc(void *ptr, size_t size);
```

`realloc` 用于**扩大或缩小**已分配内存块的大小：

```c
int *a = malloc(n * sizeof(int));
// ... 使用 a ...
a = realloc(a, 2 * n * sizeof(int));  // 扩大为原来的两倍
```

<aside>
📌

`realloc` 的行为规则：

- 如果扩大内存块，原有数据**保持不变**，新增部分**不初始化**
- 如果缩小内存块，尾部数据被截断，前面的数据保持不变
- `realloc` **可能**会移动内存块到新位置，返回新的指针
- 如果 `ptr` 为 NULL，行为等同于 `malloc(size)`
- 如果 `size` 为 0，行为等同于 `free(ptr)`
</aside>

<aside>
⚠️

**不要直接将 `realloc` 的返回值赋给原指针！** 如果 `realloc` 失败返回 NULL，原指针会丢失，导致**内存泄漏**：

```c
// ❌ 危险写法
a = realloc(a, new_size);  // 如果失败，a 变为 NULL，原内存泄漏

// ✅ 安全写法
int *temp = realloc(a, new_size);
if (temp == NULL) {
    // 处理失败，a 仍指向原内存
} else {
    a = temp;
}
```

</aside>

---

## 17.4 释放存储空间

### free 函数

`free` 的原型：

```c
void free(void *ptr);
```

每次调用 `malloc`、`calloc` 或 `realloc` 分配的内存，在不再需要时都**必须**调用 `free` 释放：

```c
char *p = malloc(100);
// ... 使用 p ...
free(p);        // 释放 p 指向的内存
p = NULL;       // 好习惯：释放后将指针置为 NULL
```

### 悬空指针问题

调用 `free(p)` 后，`p` 变成**悬空指针**（dangling pointer）——它仍然保存着原来的地址，但那块内存已经不属于程序了：

```c
free(p);
printf("%d", *p);   // ❌ 未定义行为！p 是悬空指针
```

<aside>
⚠️

**常见的动态内存错误：**

- **内存泄漏**：分配了内存但忘记释放，程序持续占用越来越多内存
- **重复释放**：对同一块内存调用两次 `free`，导致未定义行为
- **使用已释放的内存**：通过悬空指针访问已释放的内存
- **释放非动态分配的内存**：对栈变量或字符串字面量调用 `free`
</aside>

### 内存泄漏示例

```c
// 示例1：指针被覆盖，原内存无法释放
char *p = malloc(100);
p = malloc(200);     // ❌ 前 100 字节的内存泄漏了

// 示例2：函数中分配但未释放
void f(void) {
    char *p = malloc(100);
    return;          // ❌ p 是局部变量，函数返回后无法再释放这块内存
}
```

---

## 17.5 链表

### 什么是链表

**链表**（linked list）是由一系列**节点**（node）组成的数据结构，每个节点包含**数据**和指向**下一个节点的指针**。

与数组的对比：

| 特性 | 数组 | 链表 |
| --- | --- | --- |
| 大小 | 固定（或需 realloc） | 可动态增长 |
| 插入/删除 | 需要移动元素，O(n) | 修改指针即可，O(1) |
| 随机访问 | O(1)，通过下标 | O(n)，需遍历 |
| 内存 | 连续 | 不连续，每个节点额外存储指针 |

### 声明节点类型

使用结构体和指针定义链表节点：

```c
struct node {
    int value;           // 数据
    struct node *next;   // 指向下一个节点的指针
};
```

<aside>
📌

注意这里**必须**写 `struct node *next` 而不能用 typedef 的别名，因为 typedef 在声明完成之前还不可用。不过可以这样做：

```c
typedef struct node {
    int value;
    struct node *next;   // 这里仍然用 struct node
} Node;
```

</aside>

### 创建节点

```c
struct node *new_node(int value)
{
    struct node *p = malloc(sizeof(struct node));
    if (p == NULL)
        return NULL;
    p->value = value;
    p->next = NULL;
    return p;
}
```

### `->` 运算符

通过指针访问结构体成员时，使用 `->` 运算符：

```c
p->value     // 等价于 (*p).value
p->next      // 等价于 (*p).next
```

### 在链表头部插入节点

```c
struct node *add_to_head(struct node *list, int value)
{
    struct node *new = malloc(sizeof(struct node));
    if (new == NULL)
        return list;
    new->value = value;
    new->next = list;    // 新节点的 next 指向原链表头
    return new;          // 返回新的链表头
}
```

### 在链表中搜索

```c
struct node *search(struct node *list, int value)
{
    for (struct node *p = list; p != NULL; p = p->next)
        if (p->value == value)
            return p;
    return NULL;
}
```

### 从链表中删除节点

```c
struct node *delete_from_list(struct node *list, int value)
{
    struct node *cur, *prev;

    for (cur = list, prev = NULL;
         cur != NULL && cur->value != value;
         prev = cur, cur = cur->next)
        ;

    if (cur == NULL)
        return list;            // 未找到

    if (prev == NULL)
        list = list->next;      // 删除的是头节点
    else
        prev->next = cur->next; // 跳过 cur 节点

    free(cur);                  // 释放被删除的节点
    return list;
}
```

### 有序链表

维护一个**有序链表**：在插入时找到正确的位置，使链表始终保持排序状态。这样搜索时可以在发现更大的值后提前停止。

---

## 17.6 指向指针的指针

**指向指针的指针**（pointer to pointer）是一个存储另一个指针地址的变量：

```c
int i = 10;
int *p = &i;
int **pp = &p;

printf("%d\n", **pp);    // 输出 10
```

### 在链表操作中的应用

使用指向指针的指针可以简化链表操作——不需要区分"头节点"和"其他节点"的情况：

```c
void add_to_head(struct node **list, int value)
{
    struct node *new = malloc(sizeof(struct node));
    new->value = value;
    new->next = *list;
    *list = new;        // 直接修改调用者的头指针
}

// 调用
struct node *head = NULL;
add_to_head(&head, 10);   // 传头指针的地址
```

<aside>
💡

传 `struct node **list`（指向指针的指针）而不是返回新头指针，可以让函数**直接修改**调用者的头指针，代码更简洁，也不需要用返回值。

</aside>

---

## 17.7 指向函数的指针

### 函数指针的声明

C 语言中，**函数名**本身就代表函数的地址。**函数指针**是一个存储函数地址的变量：

```c
// 声明一个函数指针 pf，它指向"接收两个 int 参数、返回 int"的函数
int (*pf)(int, int);
```

<aside>
⚠️

`int (*pf)(int, int)` 和 `int *pf(int, int)` 完全不同！

- `int (*pf)(int, int)` — `pf` 是**指向函数的指针**
- `int *pf(int, int)` — `pf` 是一个**返回 `int *` 的函数**

圆括号不能省！

</aside>

### 函数指针的赋值与调用

```c
int add(int a, int b) { return a + b; }
int sub(int a, int b) { return a - b; }

int (*pf)(int, int);

pf = add;                  // pf 指向 add 函数
printf("%d\n", pf(3, 4));  // 输出 7（通过指针调用函数）
// 也可以写成 (*pf)(3, 4)，效果相同

pf = sub;                  // pf 改为指向 sub 函数
printf("%d\n", pf(3, 4));  // 输出 -1
```

### 函数指针作为参数

函数指针的最大用途是将函数作为参数传递给另一个函数，实现**回调**（callback）：

```c
// qsort 的原型（<stdlib.h>）
void qsort(void *base, size_t nmemb, size_t size,
            int (*compar)(const void *, const void *));
```

使用 `qsort` 对整数数组排序：

```c
int compare_ints(const void *a, const void *b)
{
    int arg1 = *(const int *)a;
    int arg2 = *(const int *)b;
    if (arg1 < arg2) return -1;
    if (arg1 > arg2) return 1;
    return 0;
}

int arr[] = {5, 2, 8, 1, 9};
qsort(arr, 5, sizeof(int), compare_ints);
// arr 变为 {1, 2, 5, 8, 9}
```

<aside>
📌

`qsort` 是 C 标准库中最常用的函数指针应用。它的第四个参数是一个**比较函数**的指针，`qsort` 在排序时回调这个函数来比较两个元素。这种设计使得一个通用的排序函数可以排序任意类型的数据。

</aside>

### 函数指针的其他用途

- **函数表**（dispatch table）：用函数指针数组替代冗长的 `switch` 语句

```c
// 简单计算器的函数表
double (*operations[])(double, double) = {
    add, sub, mul, divide
};

// 根据操作符索引调用对应函数
double result = operations[op_index](x, y);
```

---

## 17.8 受限指针（C99）

C99 引入了 `restrict` 关键字，用于告知编译器：在指针的生命周期内，**只有该指针（或由它派生的指针）会访问它所指向的对象**。

```c
int * restrict p = malloc(sizeof(int));
```

### 受限指针的作用

`restrict` 是对**编译器的承诺**，帮助编译器进行更激进的**优化**：

```c
// 没有 restrict：编译器必须假设 a 和 b 可能指向同一内存
void add_arrays(int *a, int *b, int *c, int n) {
    for (int i = 0; i < n; i++)
        c[i] = a[i] + b[i];
}

// 有 restrict：编译器知道 a、b、c 不会重叠，可以优化
void add_arrays(int * restrict a, int * restrict b,
                int * restrict c, int n) {
    for (int i = 0; i < n; i++)
        c[i] = a[i] + b[i];
}
```

<aside>
📌

C 标准库中许多函数的参数都使用了 `restrict`，例如：

- `memcpy(void * restrict dst, const void * restrict src, size_t n)` — 要求源和目标**不重叠**
- `memmove` 没有 `restrict`，因为它**允许重叠**

如果违反 `restrict` 的约束（即两个 restrict 指针实际指向重叠的内存），行为是**未定义的**。

</aside>

---

## 17.9 灵活数组成员（C99）

C99 允许结构体的**最后一个成员**是大小未指定的数组，称为**灵活数组成员**（flexible array member）：

```c
struct vstring {
    int len;
    char chars[];    // 灵活数组成员，没有指定大小
};
```

### 使用灵活数组成员

分配时多分配灵活数组所需的空间：

```c
struct vstring *str = malloc(sizeof(struct vstring) + n);
str->len = n;
strcpy(str->chars, "Hello");
```

<aside>
📌

灵活数组成员的规则：

- 必须是结构体的**最后一个成员**
- 结构体中必须**至少还有一个其他成员**
- `sizeof` 计算结构体大小时**不包含**灵活数组成员
- 不能用灵活数组成员声明**数组**或作为**另一个结构体的成员**
</aside>

### 与指针成员的对比

灵活数组成员相比使用指针的方案，**内存布局更紧凑**，只需要一次 `malloc`：

```c
// 方案1：指针成员（需要两次 malloc）
struct vstring1 {
    int len;
    char *chars;     // 指针，数据存储在别处
};

// 方案2：灵活数组成员（只需一次 malloc，数据紧跟在结构体后面）
struct vstring2 {
    int len;
    char chars[];    // 数据直接存储在结构体末尾
};
```

---

## 本章要点速查

| **概念** | **要点** |
| --- | --- |
| 动态分配 | `malloc` 不初始化、`calloc` 清零、`realloc` 调整大小，均返回 `void *` |
| 空指针 | `NULL` 表示不指向任何对象，分配后**必须检查** |
| 释放内存 | 用 `free` 释放，释放后置 NULL，避免悬空指针 |
| 内存泄漏 | 分配了但未释放的内存，程序运行越久占用越多 |
| 链表 | 节点包含数据和 `next` 指针，插入删除 O(1)，随机访问 O(n) |
| 指向指针的指针 | `int **pp`，可简化链表操作中对头指针的修改 |
| 函数指针 | `int (*pf)(int, int)` 存储函数地址，用于回调和函数表 |
| `restrict`（C99） | 承诺指针独占访问，帮助编译器优化 |
| 灵活数组成员（C99） | 结构体末尾的 `char data[]`，一次分配，内存紧凑 |

> 本章是指针的进阶应用。核心要点：掌握 `malloc`/`calloc`/`realloc`/`free` 的**配对使用**、理解链表的**基本操作**（创建、插入、删除、搜索）、会用**函数指针**实现回调（如 `qsort`）、了解 C99 的 `restrict` 和灵活数组成员。
>