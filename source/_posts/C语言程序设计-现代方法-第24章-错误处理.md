---
title: 第24章 错误处理
date: 2026-02-17 02:20:34
categories:
- [编程技术, C]
tags:
- C语言程序设计-现代方法
---
## 24.1 `<assert.h>` 宏：断言

### assert 宏

`assert` 是一个用于**调试**的宏，用来检测程序运行时某个条件是否为真。如果表达式为假（0），`assert` 会输出一条错误信息并终止程序。

```c
#include <assert.h>

assert(表达式);
```

- 如果**表达式为真**（非零），什么都不做，程序继续执行
- 如果**表达式为假**（0），`assert` 会：
    1. 向 `stderr` 输出一条包含表达式文本、源文件名、行号的消息
    2. 调用 `abort()` 终止程序

```c
assert(n > 0);          // 如果 n <= 0，程序终止
assert(ptr != NULL);    // 如果 ptr 为 NULL，程序终止
```

输出示例：

```
Assertion failed: n > 0, file demo.c, line 5
```

### 禁用 assert

在发布版本中，可以通过在 `#include <assert.h>` **之前**定义 `NDEBUG` 宏来禁用所有 `assert`：

```c
#define NDEBUG
#include <assert.h>
```

此时所有 `assert` 调用都会被预处理器替换为空语句 `((void)0)`，不产生任何代码。

<aside>
💡

`assert` 仅用于**调试阶段**检测"不应该发生"的情况（如程序内部逻辑错误）。不要用 `assert` 来检测运行时可预见的错误（如用户输入错误、文件打开失败），因为发布版本中 `assert` 会被禁用。

</aside>

### C99 中的 `static_assert`（补充）

C11 引入了 `_Static_assert`（`<assert.h>` 中定义了 `static_assert` 宏），用于**编译时断言**：

```c
static_assert(sizeof(int) >= 4, "int must be at least 4 bytes");
```

- 与 `assert` 不同，`static_assert` 在**编译时**检查，不影响运行时性能
- 如果条件为假，编译器会产生错误信息

## 24.2 `<errno.h>` 头：错误码

### errno 变量

`<errno.h>` 定义了一个名为 `errno` 的宏（通常表现为一个可修改的左值），用于表示**最近一次库函数调用**的错误状态。

```c
#include <errno.h>
```

- `errno` 在程序启动时为 **0**
- 某些库函数在出错时会将 `errno` 设置为**非零值**
- 库函数**成功时不会**将 `errno` 重置为 0

<aside>
⚠️

使用 `errno` 的正确步骤：

1. 在调用库函数**之前**将 `errno` 设为 0
2. 调用库函数
3. 检查返回值**和** `errno` 来判断是否出错

```c
errno = 0;
double result = sqrt(-1.0);
if (errno != 0) {
    // 发生了错误
    perror("sqrt");
}
```

</aside>

### perror 和 strerror

- `perror(s)`：向 `stderr` 输出字符串 `s`，后跟冒号和与当前 `errno` 对应的错误描述

```c
errno = 0;
FILE *fp = fopen("nofile.txt", "r");
if (fp == NULL) {
    perror("fopen");   // 输出: fopen: No such file or directory
}
```

- `strerror(errnum)`（`<string.h>`）：返回指向与错误码 `errnum` 对应的错误描述字符串的指针

```c
printf("Error: %s\n", strerror(errno));
```

### 常见的 errno 值

| 宏名 | 含义 |
| --- | --- |
| `EDOM` | 数学函数的参数超出**定义域**（如 `sqrt(-1)`） |
| `ERANGE` | 数学函数的结果超出**范围**（如溢出） |
| `EILSEQ` | 无效的多字节字符序列（C99 新增） |

<aside>
📌

C 标准只要求定义 `EDOM`、`ERANGE` 和 `EILSEQ` 这三个错误码。实际实现（如 POSIX）会定义大量额外的错误码，如 `ENOMEM`（内存不足）、`ENOENT`（文件不存在）等。

</aside>

## 24.3 `<signal.h>` 头：信号处理

### 什么是信号

**信号**是在程序执行过程中发生的异常事件的通知。信号可以由多种原因触发：

- **运行时错误**：如除以零、非法内存访问
- **外部事件**：如用户按下 Ctrl+C
- **程序自身调用** `raise` 函数

### 标准信号类型

| 信号宏 | 含义 | 典型触发场景 |
| --- | --- | --- |
| `SIGABRT` | 异常终止 | 调用 `abort()` |
| `SIGFPE` | 算术错误 | 除以零、溢出 |
| `SIGILL` | 非法指令 | 执行无效指令 |
| `SIGINT` | 中断 | 用户按 Ctrl+C |
| `SIGSEGV` | 非法内存访问 | 解引用空指针、越界 |
| `SIGTERM` | 终止请求 | 外部发送的终止信号 |

### signal 函数

`signal` 函数用于为指定信号安装**信号处理函数**（handler）：

```c
#include <signal.h>

void (*signal(int sig, void (*handler)(int)))(int);
```

用 `typedef` 简化理解：

```c
typedef void (*SignalHandler)(int);
SignalHandler signal(int sig, SignalHandler handler);
```

- `sig`：要处理的信号（如 `SIGINT`）
- `handler`：处理函数，可以是：
    - **自定义函数**：接收信号编号作为参数
    - `SIG_DFL`：恢复默认处理方式
    - `SIG_IGN`：忽略该信号
- **返回值**：之前的信号处理函数，出错时返回 `SIG_ERR`

```c
void sigint_handler(int sig)
{
    // 处理 SIGINT 信号
    printf("Caught SIGINT!\n");
    exit(EXIT_FAILURE);
}

// 安装处理函数
signal(SIGINT, sigint_handler);
```

<aside>
⚠️

**信号处理函数中的限制：**

- 不能调用大多数标准库函数（`printf` 等都不安全）
- 不能访问 `static` 或全局变量（除了 `volatile sig_atomic_t` 类型的变量）
- 在处理函数中，信号的处理方式**可能**被重置为 `SIG_DFL`（取决于实现）
</aside>

### raise 函数

`raise` 用于在程序中**主动触发**一个信号：

```c
int raise(int sig);
```

```c
raise(SIGABRT);   // 触发异常终止信号，效果类似 abort()
```

- 返回 0 表示成功，非零表示失败

### sig_atomic_t 类型

`sig_atomic_t` 是一种整数类型，保证对它的读写是**原子操作**（不会被信号中断）。在信号处理函数中，只能安全地读写 `volatile sig_atomic_t` 类型的变量：

```c
volatile sig_atomic_t flag = 0;

void handler(int sig)
{
    flag = 1;   // 安全：原子写入
}

int main(void)
{
    signal(SIGINT, handler);
    while (!flag) {
        // 等待信号
    }
    printf("Signal received!\n");
    return 0;
}
```

## 24.4 `<setjmp.h>` 头：非局部跳转

### 为什么需要非局部跳转

C 语言中，`goto` 只能在**同一函数内**跳转。当需要从深层嵌套的函数调用中直接跳回上层函数时，`goto` 无法做到。`<setjmp.h>` 提供了**非局部跳转**机制来解决这个问题。

### setjmp 和 longjmp

```c
#include <setjmp.h>

int setjmp(jmp_buf env);
void longjmp(jmp_buf env, int val);
```

**工作原理：**

- `setjmp(env)`：保存当前的执行环境（寄存器、栈指针等）到 `env` 中，**首次调用返回 0**
- `longjmp(env, val)`：恢复 `env` 中保存的执行环境，使程序跳回 `setjmp` 的位置，此时 `setjmp` **返回 val**（如果 val 为 0，则返回 1）

```c
#include <setjmp.h>
#include <stdio.h>

jmp_buf env;

void deep_function(void)
{
    printf("About to longjmp...\n");
    longjmp(env, 1);   // 跳回 setjmp 处
    // 以下代码永远不会执行
    printf("This won't print.\n");
}

int main(void)
{
    if (setjmp(env) == 0) {
        // 首次调用 setjmp，返回 0
        printf("setjmp returned 0 (initial call)\n");
        deep_function();
    } else {
        // 从 longjmp 跳回，返回非零值
        printf("Returned from longjmp!\n");
    }
    return 0;
}
```

输出：

```
setjmp returned 0 (initial call)
About to longjmp...
Returned from longjmp!
```

### 典型用途：错误处理

`setjmp`/`longjmp` 最常见的用途是实现**跨函数的错误处理**，类似于其他语言中的 `try-catch`：

```c
jmp_buf error_env;

void parse(void)
{
    // ... 解析过程中遇到错误
    longjmp(error_env, PARSE_ERROR);
}

void analyze(void)
{
    // ... 分析过程中遇到错误
    longjmp(error_env, ANALYZE_ERROR);
}

int main(void)
{
    int err = setjmp(error_env);
    if (err == 0) {
        // 正常执行路径（类似 try）
        parse();
        analyze();
    } else {
        // 错误处理路径（类似 catch）
        switch (err) {
            case PARSE_ERROR:
                printf("Parse error!\n"); break;
            case ANALYZE_ERROR:
                printf("Analyze error!\n"); break;
        }
    }
    return 0;
}
```

<aside>
⚠️

**使用 setjmp/longjmp 的注意事项：**

- 调用 `longjmp` 时，`setjmp` 所在的函数**必须仍在执行中**（未返回），否则行为未定义
- `longjmp` 不会释放动态分配的内存或关闭打开的文件——需要手动管理资源
- `setjmp` 只能出现在有限的上下文中：`if`/`switch` 条件、比较表达式、单独的表达式语句等
- 在 `setjmp` 和 `longjmp` 之间修改的**非 volatile 局部变量**的值是不确定的
</aside>

<aside>
📌

`setjmp`/`longjmp` 本质上是 C 语言对**异常处理**的底层支持。C++ 的 `try`/`catch` 和 Java 的异常机制都是在这个思想上发展而来的，但提供了更安全和自动化的资源管理。

</aside>

## 24.5 小结

| 机制 | 头文件 | 用途 | 关键点 |
| --- | --- | --- | --- |
| `assert` | `<assert.h>` | 调试时检测逻辑错误 | 可通过 `NDEBUG` 禁用 |
| `errno` | `<errno.h>` | 检测库函数调用错误 | 调用前清零，调用后检查 |
| `signal`/`raise` | `<signal.h>` | 处理异步事件和异常 | 处理函数中限制多 |
| `setjmp`/`longjmp` | `<setjmp.h>` | 非局部跳转/错误恢复 | 不自动释放资源 |

> C 语言的错误处理机制比较原始但灵活：`assert` 用于调试、`errno` 用于检测库函数错误、`signal` 用于处理异步事件、`setjmp`/`longjmp` 用于实现跨函数的错误恢复。理解这些机制是编写**健壮 C 程序**的基础。
>