---
title: 第15章 编写大规模程序
date: 2026-02-17 02:20:28
categories:
- [编程技术, C]
---
## 15.1 源文件

### 把程序拆分成多个文件

当程序规模变大时，把所有代码放在一个文件里会变得难以维护。C 语言允许将程序拆分成多个**源文件**（`.c` 文件），每个文件包含程序的一部分（通常是一组相关的函数）。

- 一个源文件包含程序的一部分——主要是**函数定义**和**变量定义**
- 其中一个源文件必须包含 `main` 函数，作为程序入口
- 其他源文件提供 `main` 调用的函数

### 拆分的优势

- **逻辑分组**：把相关的函数和变量放在同一个文件中，结构更清晰
- **分别编译**：修改一个源文件后，只需重新编译该文件，无需重新编译整个程序
- **代码复用**：一个源文件中的函数可以被多个程序共享

## 15.2 头文件

### 什么是头文件

头文件（`.h` 文件）是在源文件之间共享信息的桥梁。头文件中通常包含：

- **函数原型**（声明）
- **宏定义**
- **类型定义**（`typedef`、结构体等）
- **外部变量声明**（`extern`）

```c
/* stack.h —— 栈模块的头文件 */
#ifndef STACK_H
#define STACK_H

void make_empty(void);
int is_empty(void);
void push(int i);
int pop(void);

#endif
```

### #include 指令

`#include` 指令让预处理器将指定头文件的内容插入到当前源文件中：

```c
#include <stdio.h>      // 搜索系统头文件目录
#include "stack.h"       // 先搜索当前目录，再搜索系统目录
```

- `< >`：用于**系统头文件**（标准库等）
- `" "`：用于**自定义头文件**（程序员编写的）

<aside>
📌

`#include` 本质上只是**文本替换**——预处理器把头文件的全部内容复制粘贴到 `#include` 所在的位置。

</aside>

### 共享宏定义和类型定义

头文件适合存放需要在多个源文件间共享的宏和类型：

```c
/* common.h */
#ifndef COMMON_H
#define COMMON_H

#define BOOL int
#define TRUE 1
#define FALSE 0

typedef struct {
    int x;
    int y;
} Point;

#endif
```

任何需要使用 `BOOL` 或 `Point` 的源文件，只需 `#include "common.h"` 即可。

### 共享函数原型

最重要的用途：头文件存放**函数原型**（即函数声明），源文件存放**函数定义**（即函数实现）。

```c
/* stack.h —— 声明 */
void push(int i);
int pop(void);
```

```c
/* stack.c —— 定义（实现） */
#include "stack.h"

static int contents[100];
static int top = 0;

void push(int i) {
    contents[top++] = i;
}

int pop(void) {
    return contents[--top];
}
```

```c
/* main.c —— 使用 */
#include "stack.h"

int main(void) {
    push(1);
    push(2);
    printf("%d\n", pop());  // 输出 2
    return 0;
}
```

<aside>
💡

源文件自己也要 `#include` 自己对应的头文件（如 `stack.c` 包含 `stack.h`），这样编译器可以**检查函数定义和声明是否一致**，在不一致时给出错误提示。

</aside>

### 共享变量声明

如果多个源文件需要共享一个全局变量，需要在头文件中用 `extern` **声明**，在某个源文件中**定义**：

```c
/* shared.h */
extern int error_count;     // 声明（不分配内存）
```

```c
/* shared.c */
#include "shared.h"
int error_count = 0;        // 定义（分配内存，可初始化）
```

```c
/* main.c */
#include "shared.h"
// 可以直接使用 error_count
error_count++;
```

<aside>
⚠️

- `extern int x;` 是**声明**——告诉编译器 `x` 在别处定义，不分配内存
- `int x;` 或 `int x = 0;` 是**定义**——实际分配内存
- 变量**只能定义一次**，但可以声明多次
</aside>

### 保护头文件：#ifndef 守卫

如果同一个头文件被间接 `#include` 多次，会导致重复定义错误。解决方法是使用**包含守卫**（include guard）：

```c
#ifndef STACK_H
#define STACK_H

/* 头文件内容 */

#endif
```

工作原理：

1. 第一次包含时，`STACK_H` 未定义，条件成立，定义 `STACK_H` 并处理内容
2. 后续再次包含时，`STACK_H` 已定义，条件不成立，跳过所有内容

<aside>
📌

**每个头文件都应该使用包含守卫。** 宏名称通常采用 `文件名大写_H` 的命名惯例，如 `stack.h` 对应 `STACK_H`。

</aside>

### #error 指令

`#error` 可以在编译期检测配置错误并给出提示信息：

```c
#if INT_MAX < 100000
#error int type is too small
#endif
```

如果条件成立，编译器将终止编译并输出指定的错误消息。

## 15.3 把程序划分成多个文件

### 设计原则

拆分程序时，应遵循**高内聚、低耦合**的原则：

- **每个源文件是一个模块**：包含一组**逻辑相关**的函数
- **接口与实现分离**：头文件（`.h`）定义接口，源文件（`.c`）实现细节
- **信息隐藏**：用 `static` 隐藏模块内部的函数和变量，只暴露必要的接口

### 典型的文件组织方式

一个模块通常由**一对文件**组成：

```
stack.h    ← 接口（函数原型、类型定义、宏）
stack.c    ← 实现（函数定义、内部变量）
```

其他文件通过 `#include "stack.h"` 使用该模块，但无需了解 `stack.c` 的内部细节。

### 使用 static 隐藏内部细节

在源文件中，用 `static` 修饰的函数和变量**仅在本文件内可见**，外部无法访问：

```c
/* stack.c */
#include "stack.h"

static int contents[100];   // 仅 stack.c 内部可见
static int top = 0;         // 仅 stack.c 内部可见

static void check_overflow(void) {  // 内部辅助函数
    if (top >= 100) {
        printf("Stack overflow\n");
        exit(1);
    }
}

void push(int i) {          // 外部可见（在 stack.h 中声明）
    check_overflow();
    contents[top++] = i;
}

int pop(void) {              // 外部可见
    return contents[--top];
}
```

<aside>
💡

`static` 在文件作用域有两层含义：

- **内部链接**：该名称仅在当前源文件内可见
- **信息隐藏**：防止外部代码意外访问或修改模块内部状态

这是 C 语言实现**封装**的主要手段。

</aside>

## 15.4 构建多文件程序

### 编译与链接的过程

构建多文件程序分为两步：

1. **编译**（Compile）：将每个 `.c` 文件分别编译为**目标文件**（`.o` 或 `.obj`）
2. **链接**（Link）：将所有目标文件合并为一个**可执行文件**

```
stack.c  →  编译  →  stack.o  ─┐
main.c   →  编译  →  main.o   ─┤→  链接  →  可执行文件
utils.c  →  编译  →  utils.o  ─┘
```

### 使用 GCC 编译

```bash
# 一步完成编译和链接
gcc -o program main.c stack.c utils.c

# 分步编译
gcc -c main.c        # 生成 main.o
gcc -c stack.c       # 生成 stack.o
gcc -c utils.c       # 生成 utils.o
gcc -o program main.o stack.o utils.o   # 链接
```

分步编译的好处：修改了 `stack.c` 后，只需重新编译 `stack.c`，然后重新链接即可。

### Makefile

当源文件较多时，手动编译很繁琐。**make** 工具和 **Makefile** 可以自动管理编译流程：

```makefile
program: main.o stack.o utils.o
	gcc -o program main.o stack.o utils.o

main.o: main.c stack.h utils.h
	gcc -c main.c

stack.o: stack.c stack.h
	gcc -c stack.c

utils.o: utils.c utils.h
	gcc -c utils.c

clean:
	rm -f *.o program
```

- 每条规则的格式：`目标: 依赖`，下一行是生成目标的命令
- `make` 会根据文件的**修改时间**判断哪些文件需要重新编译
- 只有被修改过的源文件（及依赖它的目标）会被重新编译

<aside>
📌

Makefile 中命令行前必须使用 **Tab 字符**缩进，不能使用空格，否则 `make` 会报错。这是初学者常遇到的问题。

</aside>

### 链接期间的错误

编译可以通过但链接可能失败的常见情况：

- **未定义引用**（undefined reference）：调用了某个函数但没有提供对应的 `.o` 文件
- **重复定义**（multiple definition）：同一个函数或全局变量在多个源文件中定义
- **声明与定义不匹配**：头文件中的函数原型与源文件中的函数定义参数类型不一致

## 15.5 小结

| 概念 | 说明 |
| --- | --- |
| 源文件 `.c` | 包含函数定义和变量定义，是程序的实现 |
| 头文件 `.h` | 包含函数原型、宏、类型定义、`extern` 声明，是模块的接口 |
| `#include <>` | 包含系统头文件 |
| `#include ""` | 包含自定义头文件 |
| `extern` | 声明在别处定义的变量（不分配内存） |
| `static`（文件作用域） | 限制函数/变量仅在当前文件可见，实现信息隐藏 |
| 包含守卫 | `#ifndef / #define / #endif` 防止头文件重复包含 |
| 编译 | `.c` → `.o`，分别编译各源文件 |
| 链接 | 多个 `.o` → 可执行文件 |
| Makefile | 自动化管理编译流程，只重编修改过的文件 |

> 编写大规模程序的核心思想：**将程序拆分为多个模块，每个模块由头文件定义接口、源文件实现细节，用 `static` 隐藏内部状态，通过 `#include` 共享声明，用 Makefile 管理构建流程。** 这是 C 语言工程化开发的基础。
>